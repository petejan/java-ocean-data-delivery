/*
 * IMOS Data Delivery Project
 * Written by Peter Jansen
 * This code is copyright (c) Peter Jansen 2000 - ?
 * It is made available under the BSD Software Licence in the hope that it may be useful.
 * It has NO WARRANTY OF FITNESS OR SUITABILITY FOR ANY PURPOSE.
 * Feel free to fix any bugs that you may find.
 */

/*
 * NetCDFcreateForm.java
 *
 * Created on 8 June 2013
 */

package org.imos.abos.forms;

import java.awt.Color;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.TimeZone;
import java.util.Vector;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JComboBox;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.imos.abos.dbms.Instrument;
import org.imos.abos.dbms.InstrumentCalibrationValue;
import org.imos.abos.dbms.Mooring;
import org.imos.abos.dbms.ParameterCodes;
import org.imos.abos.dbms.RawInstrumentData;
import org.imos.abos.instrument.AanderraOptodeConstants;
import org.wiley.core.Common;
import org.wiley.core.forms.MemoryWindow;
import org.wiley.util.SQLWrapper;
import org.wiley.util.StringUtilities;
import org.wiley.util.TextFileLogger;
import ucar.ma2.ArrayByte;
import ucar.ma2.ArrayFloat;
import ucar.ma2.ArrayInt;
import ucar.ma2.DataType;
import ucar.ma2.Index;
import ucar.ma2.InvalidRangeException;
import ucar.nc2.Dimension;
import ucar.nc2.NetcdfFileWriteable;

/**
 *
 * @author peter
 */
public class NetCDFcreateForm extends MemoryWindow
{
    private static Logger logger = Logger.getLogger(NetCDFcreateForm.class.getName());
    protected static SQLWrapper query = new SQLWrapper();
    
    private Mooring selectedMooring = null;
    private Instrument sourceInstrument = null;
    
    private String authority = "OS";
    private String site = "SOTS";
    private String mooring = "PULSE";
    private String deployment = "Pulse-8-2011";
    private String parameter = "";
    
    protected NetcdfFileWriteable dataFile = null;
    protected TimeZone tz = TimeZone.getTimeZone("UTC");
    
    /** Creates new form SBE16CalculationForm */
    public NetCDFcreateForm()
    {
        TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
    }
    
    @Override
    public void initialise()
    {
        initComponents();
        
        this.setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        jPanel1 = new javax.swing.JPanel();
        mooringCombo1 = new org.imos.abos.dbms.fields.MooringCombo();
        mooringDescriptionField = new org.wiley.util.basicField();
        sourceInstrumentCombo = new org.imos.abos.dbms.fields.InstrumentSelectorCombo();
        jPanel2 = new javax.swing.JPanel();
        runButton = new javax.swing.JButton();
        quitButton = new javax.swing.JButton();

        setTitle("Aanderra Optode Data Processing Form");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent evt)
            {
                formWindowClosing(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        mooringCombo1.setDescriptionField(mooringDescriptionField);
        mooringCombo1.setOrientation(0);
        mooringCombo1.addPropertyChangeListener(new java.beans.PropertyChangeListener()
        {
            public void propertyChange(java.beans.PropertyChangeEvent evt)
            {
                mooringCombo1PropertyChange(evt);
            }
        });

        mooringDescriptionField.setEnabled(false);

        sourceInstrumentCombo.setOrientation(0);

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 169, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 343, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(0, 0, Short.MAX_VALUE))
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
                        .add(0, 0, Short.MAX_VALUE)
                        .add(sourceInstrumentCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 562, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 21, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(139, 139, 139)
                .add(sourceInstrumentCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 26, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(288, 288, 288))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        runButton.setText("Run");
        runButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                runButtonActionPerformed(evt);
            }
        });
        jPanel2.add(runButton);

        quitButton.setText("Quit");
        quitButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                quitButtonActionPerformed(evt);
            }
        });
        jPanel2.add(quitButton);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 300, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 21, Short.MAX_VALUE)
                .add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );

        getAccessibleContext().setAccessibleName("SBE16 Extraction Processing Form");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void quitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitButtonActionPerformed
        cleanup();
    }//GEN-LAST:event_quitButtonActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        cleanup();
    }//GEN-LAST:event_formWindowClosing

    private void runButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runButtonActionPerformed

        sourceInstrument = sourceInstrumentCombo.getSelectedInstrument();

        selectedMooring = mooringCombo1.getSelectedMooring();

        if(selectedMooring == null)
        {
            Common.showMessage(this,"No Mooring Selected","You must select a mooring before running any calculations");
            return;
        }

        final Color bg = runButton.getBackground();
        runButton.setText("Running...");
        runButton.setBackground(Color.RED);
        runButton.setForeground(Color.WHITE);

        Thread worker = new Thread()
        {
            @Override
            public void run()
            {
                SwingUtilities.invokeLater(new Runnable()
                {
                @Override
                    public void run()
                    {
                        runButton.setBackground(bg);
                        runButton.setForeground(Color.BLACK);
                        runButton.setText("Run");
                        repaint();
                        createTimeArray(deployment);
                        createDepthArray(deployment);
                        createCDFFile();                        
                    }
                });
            }
        };

        worker.start();      
        
    }//GEN-LAST:event_runButtonActionPerformed

    private void mooringCombo1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_mooringCombo1PropertyChange
        String propertyName = evt.getPropertyName();
        //logger.debug(evt.getPropertyName());
        if(propertyName.equalsIgnoreCase("MOORING_SELECTED")) {
            Mooring selectedItem = (Mooring) evt.getNewValue();
            sourceInstrumentCombo.setMooring(selectedItem);
        }
    }//GEN-LAST:event_mooringCombo1PropertyChange

    protected Timestamp endTime = null;
    protected Timestamp startTime = null;
    protected ArrayList<Timestamp> timeArray = new ArrayList();
    
    protected String getFileName()
    {
        SimpleDateFormat nameFormatter = new SimpleDateFormat("yyyyMMdd'T'HHmmss'Z'");
        nameFormatter.setTimeZone(tz);

        String filename = "ABOS_NetCDF.nc";
        
        if (authority.equals("IMOS"))
        {
            filename = //System.getProperty("user.home")
                            //+ "/"
                            authority 
                            + "_" + deployment.toUpperCase()
                            + "_START_"
                            + nameFormatter.format(startTime)
                            + "_END_"
                            + nameFormatter.format(endTime)
                            + "_CREATE_"               
                            + nameFormatter.format(System.currentTimeMillis())
                            + ".nc"
                            ;
        }
        else if (authority.equals("OS"))
        {
            filename = "OS"
                        + "_SOTS"
                        + "_PULSE-8-2011"
                        + "_D"
                        + ".nc"
                        ;
        }

        return filename;
    }
    
    
    protected void writeMooringSpecificAttributes()
    {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss\'Z\'");
        df.setTimeZone(tz);

        String SQL = "SELECT attribute_name, attribute_type, attribute_value FROM netcdf_attributes "
                        + "WHERE deployment = " + StringUtilities.quoteString(deployment) 
                        + " AND (naming_authority = " + StringUtilities.quoteString(authority) + " OR naming_authority ISNULL)"
                        + " AND parameter ISNULL"
                        + " ORDER BY attribute_name";
        query.setConnection(Common.getConnection());
        query.executeQuery(SQL);
        Vector attributeSet = NetCDFcreateForm.query.getData();
        if (attributeSet != null && attributeSet.size() > 0)
        {
            for (int i = 0; i < attributeSet.size(); i++)
            {
                Vector row = (Vector) attributeSet.get(i);
                String name = (String)(row.get(0));
                String type = (String)(row.get(1));
                String value = (String)(row.get(2));

                logger.debug("MOORING: " + name + " = " + value);

                dataFile.addGlobalAttribute(name.trim(), value.trim());                
            }
        }
    }

    private class DepthCoord
    {
        String[] params;
        Double[] depths;
        Integer[] instruments;
        Dimension dim;
        String dimensionName;
        private ArrayFloat.D1 variable;
        private ArrayList<Dimension> timeAndDim;
        String depthsString;
        String[] varName;
        String[] varNameQC;
        ArrayFloat.D2[] dataVar;
        ArrayByte.D2[] dataVarQC;
    }
    ArrayList<DepthCoord> depthCoords = new ArrayList<DepthCoord>();

    protected void createDepthArray(String mooringID)
    {
        // TODO: maybe should arrgigate over instrument not depth (where two instruments are the same depth
        String SQL = "SELECT array_agg(parameter_code) AS parameters, instruments, depths AS depths "
                    + "FROM "
                    + "(SELECT parameter_code, array_agg(instrument_id) AS instruments, array_agg(depth) AS depths FROM "
                    + "   (SELECT parameter_code, instrument_id, min(depth) AS depth FROM processed_instrument_data WHERE "
                    +        "mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID()) + " GROUP BY parameter_code, instrument_id ORDER BY 1,3"
                    + "   ) AS a"
                    + "    GROUP BY parameter_code"
                    + ") AS b"
                    + " GROUP BY depths, instruments";
        
        logger.debug(SQL);
        query.setConnection(Common.getConnection());
        query.executeQuery(SQL);
        Vector depthSet = NetCDFcreateForm.query.getData();
        
        if (depthSet != null && depthSet.size() > 0)
        {
            for (int i = 0; i < depthSet.size(); i++)
            {
                DepthCoord dc = new DepthCoord();
                dc.dimensionName = "DEPTH_" + (i + 1);

                Vector row = (Vector) depthSet.get(i);
                Array params = (Array)row.get(0);

                try
                {
                    dc.params = (String[])params.getArray();;
                    int l = dc.params.length;
                    dc.dataVar = new ArrayFloat.D2[l];
                    dc.dataVarQC = new ArrayByte.D2[l];
                    dc.varName = new String[l];
                    dc.varNameQC = new String[l];
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                Array instruments = (Array)row.get(1);
                System.out.println("instruments " + instruments);
                try
                {
                    dc.instruments = (Integer[])instruments.getArray();
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                
                Array depths = (Array)row.get(2);
                System.out.println("depths " + depths);
                try
                {
                    BigDecimal[] sDepths = (BigDecimal[])depths.getArray();
                    Double[] dDepths = new Double[sDepths.length];
                    int j = 0;
                    String ds = "(";
                    for (BigDecimal s : sDepths)
                    {
                        dDepths[j++] = s.doubleValue();
                        ds += s.doubleValue() + " ";
                    }
                    ds += ")";
                    dc.depths = dDepths;
                    dc.depthsString = ds;
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                depthCoords.add(dc);
            }
        }
        logger.debug("Finished generating depth array, number of depths is " + depthCoords.size());
    }

    protected void createTimeArray(String mooringID)
    {
        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
        selectedMooring = Mooring.selectByMooringID(mooringID);
        startTime = selectedMooring.getTimestampIn();
        endTime = selectedMooring.getTimestampOut();
        tz = TimeZone.getTimeZone("GMT");
        GregorianCalendar cal = (GregorianCalendar) Calendar.getInstance();
        cal.setTimeZone(tz);
        cal.setTimeInMillis(startTime.getTime());
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long baseMillis = cal.getTimeInMillis();
        Timestamp current = new Timestamp(baseMillis);
        logger.debug("Starting timestamp is " + current);
        while (current.before(endTime))
        {
            timeArray.add(new Timestamp(baseMillis));
            baseMillis += 3600000;
            current.setTime(baseMillis);
        }
        timeArray.add(current);
        logger.debug("Finished generating time array, last timestamp was " + current + "\nTotal Elements: " + timeArray.size());
    }

    protected ArrayList<NetCDFcreateForm.ParamDatum> getDataForParameter(String param, Integer instrumentID)
    {
        ArrayList<NetCDFcreateForm.ParamDatum> set = new ArrayList();
        logger.debug("Searching for data for param " + param + " instrument " + instrumentID);
        String SQL = "SELECT data_timestamp," 
                + " instrument_id,"
                + " depth,"
                + " parameter_code,"
                + " parameter_value,"
                + " quality_code"
                + " FROM processed_instrument_data"
                + " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID())
                + " AND parameter_code = " + StringUtilities.quoteString(param)
                + " AND instrument_id = " + instrumentID
                + " AND data_timestamp between "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(startTime))
                + " AND "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(endTime))
                + " ORDER BY data_timestamp"
                ;
        // logger.debug(SQL);
        NetCDFcreateForm.query.setConnection(Common.getConnection());
        NetCDFcreateForm.query.executeQuery(SQL);
        Vector dataSet = NetCDFcreateForm.query.getData();
        if (dataSet != null && dataSet.size() > 0)
        {
            for (int i = 0; i < dataSet.size(); i++)
            {
                Vector row = (Vector) dataSet.get(i);
                Timestamp t = (Timestamp) row.get(0);
                Integer ix = ((Number) row.get(1)).intValue();
                Double d = ((Number) row.get(2)).doubleValue();
                String p = (String) row.get(3);
                Double v = ((Number) row.get(4)).doubleValue();
                String q = (String) row.get(5);
                NetCDFcreateForm.ParamDatum dd = new NetCDFcreateForm.ParamDatum(t, ix, p, d, v, q);
                set.add(dd);
            }
            logger.debug("Found " + dataSet.size() + " records for instrument " + instrumentID);
            
            return set;
        }
        
        logger.debug("Found 0 records for pressure data for depth " + instrumentID);
        return null;
    }

    protected void writeCoordinateVariableAttributes()
    {
        dataFile.addVariableAttribute("TIME", "name", "time");
        dataFile.addVariableAttribute("TIME", "long_name", "time");
        dataFile.addVariableAttribute("TIME", "units", "hours since 1950-01-01T00:00:00Z");
        dataFile.addVariableAttribute("TIME", "axis", "T");
        dataFile.addVariableAttribute("TIME", "valid_min", 0.0);
        dataFile.addVariableAttribute("TIME", "valid_max", 999999999);
        dataFile.addVariableAttribute("TIME", "calendar", "gregorian");

        for(DepthCoord dc : depthCoords)
        {
            dataFile.addVariableAttribute(dc.dimensionName, "name", "depth");
            dataFile.addVariableAttribute(dc.dimensionName, "long_name", "Depth of each measurement");
            dataFile.addVariableAttribute(dc.dimensionName, "units", "meters");
            dataFile.addVariableAttribute(dc.dimensionName, "positive", "down");
            dataFile.addVariableAttribute(dc.dimensionName, "axis", "Z");
            dataFile.addVariableAttribute(dc.dimensionName, "comment", "These are nominal values. Use PRES to derive time-varying depths of instruments, as the mooring may tilt in ambient currents.");
            dataFile.addVariableAttribute(dc.dimensionName, "reference", "sea_level");
            dataFile.addVariableAttribute(dc.dimensionName, "valid_min", 0.0f);
            dataFile.addVariableAttribute(dc.dimensionName, "valid_max", 1200.0f);
        }
    }

    protected void writeGlobalAttributes()
    {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss\'Z\'");
        df.setTimeZone(tz);
        
        String SQL = "SELECT attribute_name, attribute_type, attribute_value FROM netcdf_attributes "
                + " WHERE (naming_authority = " + StringUtilities.quoteString(authority) + " OR naming_authority ISNULL)"
                + " AND (site = " + StringUtilities.quoteString(site) + " OR "
                + "      mooring = " + StringUtilities.quoteString(mooring) + ") "
                + " AND deployment ISNULL AND instrument_id ISNULL AND parameter ISNULL" 
                + " ORDER BY attribute_name";
        query.setConnection(Common.getConnection());
        query.executeQuery(SQL);
        Vector attributeSet = NetCDFcreateForm.query.getData();
        if (attributeSet != null && attributeSet.size() > 0)
        {
            for (int i = 0; i < attributeSet.size(); i++)
            {
                Vector row = (Vector) attributeSet.get(i);
                String name = (String)(row.get(0));
                String type = (String)(row.get(1));
                String value = (String)(row.get(2));

                logger.debug("GLOBAL: " + name + " = " + value);                

                dataFile.addGlobalAttribute(name.trim(), value.trim());
            }
        }        
    }

    protected void addVariableAttributes(DepthCoord dc, int p)
    {
        ParameterCodes param = ParameterCodes.selectByID(dc.params[p]);
        String variable = dc.varName[p];

        String sensor = "";
        String serialNo = "";
        
        for(int i=0;i<dc.instruments.length;i++)
        {
            Instrument ins = Instrument.selectByInstrumentID(dc.instruments[i]);
            if (ins != null)
            {
                sensor += ins.getMake() + "-" + ins.getModel();
                if (i < dc.instruments.length-1)
                    sensor += ";";
                serialNo += ins.getSerialNumber();
                if (i < dc.instruments.length-1)
                    serialNo += ";";
                
                ArrayList<InstrumentCalibrationValue> values = InstrumentCalibrationValue.selectByInstrumentAndMooring(ins.getInstrumentID(), selectedMooring.getMooringID());            

                for(InstrumentCalibrationValue v : values)
                {
                    // System.out.println("Calibration Value " + v.getParameterCode() + " " + v.getParameterValue());
                    if (v.getDataType().contains("NUMBER"))
                    {
                        dataFile.addVariableAttribute(variable, "calibration_" + ins.getSerialNumber() + "_" + v.getParameterCode(), Double.parseDouble(v.getParameterValue()));
                    }
                    else
                    {
                        dataFile.addVariableAttribute(dc.varName[p], "calibration_" + ins.getSerialNumber() + "_" + v.getParameterCode(), v.getParameterValue());
                    }
                }
            }
        }
        dataFile.addVariableAttribute(variable, "sensor_name", sensor);
        dataFile.addVariableAttribute(variable, "sensor_serial_number", serialNo);
            
        
        if(param != null)
        {
            dataFile.addVariableAttribute(variable, "name", param.getDescription());
            if (param.getUnits() != null)
            {
                dataFile.addVariableAttribute(variable, "units", param.getUnits());
            }
            
            if(param.getNetCDFStandardName() != null && !(param.getNetCDFStandardName().trim().isEmpty()))
                dataFile.addVariableAttribute(variable, "standard_name", param.getNetCDFStandardName());
            else if (param.getNetCDFStandardName() != null)
                dataFile.addVariableAttribute(variable, "long_name", param.getNetCDFLongName());
            
            if(param.getMinimumValidValue() != null)
                dataFile.addVariableAttribute(variable, "valid_min", param.getMinimumValidValue());
            
            if(param.getMaximumValidValue() != null)
                dataFile.addVariableAttribute(variable, "valid_max", param.getMaximumValidValue());
            
            dataFile.addVariableAttribute(variable, "_FillValue", Float.NaN);
            dataFile.addVariableAttribute(variable, "quality_control_set", 1.0f);
            //dataFile.addVariableAttribute(variable, "csiro_instrument_id", instrumentID);
        }
        
        String SQL = "SELECT attribute_name, attribute_type, attribute_value FROM netcdf_attributes "
                        + " WHERE (deployment = " + StringUtilities.quoteString(deployment) + " OR deployment ISNULL)"
                        + " AND parameter = " + StringUtilities.quoteString(variable.trim()) + " ORDER BY attribute_name";
        
        query.setConnection(Common.getConnection());
        query.executeQuery(SQL);
        Vector attributeSet = NetCDFcreateForm.query.getData();
        if (attributeSet != null && attributeSet.size() > 0)
        {
            for (int i = 0; i < attributeSet.size(); i++)
            {
                Vector row = (Vector) attributeSet.get(i);
                String name = (String)(row.get(0));
                String type = (String)(row.get(1));
                String value = (String)(row.get(2));

                logger.debug("PARAMETER: " + name + " " + value);
                
                dataFile.addVariableAttribute(variable, name.trim(), value.trim());
            }
        }
        
    }

    protected void createCDFFile()
    {
        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        long anchorTime = 0;
        try
        {
            java.util.Date ts = df.parse("1950-01-01 00:00:00");
            anchorTime = ts.getTime();
        }
        catch (ParseException pex)
        {
            logger.error(pex);
        }
        String filename = getFileName();
        int RECORD_COUNT = timeArray.size();
        try
        {
            // Create new netcdf-3 file with the given filename
            dataFile = NetcdfFileWriteable.createNew(filename, false);
            writeGlobalAttributes();
            writeMooringSpecificAttributes();

            // Define the coordinate variables.
            // Add TIME coordinate
            Dimension timeDim = dataFile.addDimension("TIME", RECORD_COUNT);
            ArrayInt.D1 times = new ArrayInt.D1(timeDim.getLength());
            Calendar cal = Calendar.getInstance();
            cal.setTimeZone(tz);
            for (int i = 0; i < timeDim.getLength(); i++)
            {
                Timestamp ts = timeArray.get(i);
                long offsetTime = (ts.getTime() - anchorTime) / 1000;
                int elapsedHours = (int) offsetTime / 3600;
                times.set(i, elapsedHours);
            }            
            dataFile.addVariable("TIME", DataType.INT, new Dimension[]{timeDim});

            // Add Depth coords
            for(DepthCoord dc : depthCoords)
            {
                dc.dim = dataFile.addDimension(dc.dimensionName, dc.depths.length);
                dataFile.addVariable(dc.dimensionName, DataType.FLOAT, new Dimension[]{dc.dim});
                ArrayFloat.D1 depths = new ArrayFloat.D1(dc.dim.getLength());
                for (int j = 0; j < dc.dim.getLength(); j++)
                {
                    Double currentDepth = dc.depths[j];
                    depths.set(j, currentDepth.floatValue());
                }
                dc.variable = depths;

                System.out.println("Create Dimension " + dc.dimensionName + " " + timeDim.getLength() + " x " + dc.dim.getLength());
                ArrayList dims = new ArrayList();
                dims.add(timeDim);
                dims.add(dc.dim);
                dc.timeAndDim = dims;
            }

            //
            // got to add the variables before you can write their attributes
            //
            writeCoordinateVariableAttributes();
            
            for (DepthCoord dc : depthCoords)
            {                
                for (int p=0;p<dc.params.length;p++)
                {
                    String pt = dc.params[p].trim();
                    ArrayFloat.D2 dataTemp = new ArrayFloat.D2(RECORD_COUNT, dc.depths.length);
                    ArrayByte.D2 dataTempQC = new ArrayByte.D2(RECORD_COUNT, dc.depths.length);
                    byte b = 9;
                    for(int i=0;i<RECORD_COUNT;i++)
                    {
                        for(int j=0;j<dc.depths.length;j++)
                        {
                            dataTemp.set(i, j, Float.NaN);
                            dataTempQC.set(i, j, b);
                        }
                    }
                    dc.varName[p] = pt;
                    dc.dataVar[p] = dataTemp;
                    dc.dataVarQC[p] = dataTempQC;
                    dataFile.addVariable(pt, DataType.FLOAT, dc.timeAndDim);
                    dataFile.addVariableAttribute(pt, "sensor_depth", dc.depthsString);
                    addVariableAttributes(dc, p);
                                        
                    String qc = pt + "_QC";
                    dataFile.addVariableAttribute(pt, "ancillary_variables", qc);
                    dc.varNameQC[p] = qc;
                    dataFile.addVariable(qc, DataType.BYTE, dc.timeAndDim);
                    dataFile.addVariableAttribute(qc, "long_name", "quality flag");
                    dataFile.addVariableAttribute(qc, "Conventions", "OceanSITES reference table 2");
                    b = 9;
                    dataFile.addVariableAttribute(qc, "_FillValue", b);
                    b = 0;
                    dataFile.addVariableAttribute(qc, "valid_min", b);
                    b = 9;
                    dataFile.addVariableAttribute(qc, "valid_max", b);

                    for (int d=0;d<dc.instruments.length;d++)
                    {
                        ArrayList<ParamDatum> masterSet = getDataForParameter(pt, dc.instruments[d]);
                        if (masterSet != null && masterSet.size() > 0)
                        {
                            logger.debug("Processing instrument/parameter " + pt + " at depth " + masterSet.get(0).depth + " size " + masterSet.size());

                            int record = 0;
                            int matchedElements = 0;
                            Double SST;
                            for (int setSize = 0; setSize < masterSet.size(); setSize++)
                            {
                                Timestamp currentTime = timeArray.get(record);
                                ParamDatum currentValue = masterSet.get(setSize);
                                while (currentTime.before(currentValue.ts))
                                {
                                    currentTime = timeArray.get(++record);
                                }
                                if (currentValue.ts.equals(currentTime))
                                {
                                    matchedElements++;
                                    SST = currentValue.val;
                                    dataTemp.set(record, d, SST.floatValue());
                                    b = 0;
                                    if (currentValue.quality.trim().equals("BAD"))
                                    {
                                        b = 4;
                                    }
                                    dataTempQC.set(record, d, b);
                                }
                                record++;                                                
                            }
                           logger.debug("Matched " + matchedElements + " records for " + pt);
                        }
                    }                    
                }
            }
            //Create the file. At this point the (empty) file will be written to disk
            dataFile.create();
            for(DepthCoord dc : depthCoords)
            {
                dataFile.write(dc.dimensionName, dc.variable);
            }
            dataFile.write("TIME", times);
            for(DepthCoord dc : depthCoords)
            {
                for(int p=0;p<dc.dataVar.length;p++)
                {
                    dataFile.write(dc.varName[p], dc.dataVar[p]);
                    dataFile.write(dc.varNameQC[p], dc.dataVarQC[p]);
                }
            }
        }
        catch (IOException e)
        {
            e.printStackTrace(System.err);
        }
        catch (InvalidRangeException e)
        {
            e.printStackTrace(System.err);
        }
        finally
        {
            if (dataFile != null)
            {
                try
                {
                    dataFile.close();
                }
                catch (IOException ioe)
                {
                    ioe.printStackTrace();
                }
            }
        }
        System.out.println("*** SUCCESS writing file " + filename);
    }

    protected class ParamDatum
    {
        public Timestamp ts;
        public Integer instrumentID;
        public String paramCode;
        public Double depth;
        public Double val;
        public String quality;

        public ParamDatum()
        {
            super();
        }

        public ParamDatum(Timestamp t, Integer i, String p, Double d, Double v, String q)
        {
            super();
            ts = t;
            instrumentID = i;
            paramCode = p.trim();
            depth = d;
            val = v;
            quality = q;
        }
    }
    
    
    /**
    * @param args the command line arguments
    */
    public static void main(String[] args)
    {
        try
        {
	    // Set cross-platform Java L&F (also called "Metal")
            UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
        }
        catch (UnsupportedLookAndFeelException e)
        {
           // handle exception
        }
        catch (ClassNotFoundException e)
        {
           // handle exception
        }
        catch (InstantiationException e)
        {
           // handle exception
        }
        catch (IllegalAccessException e)
        {
           // handle exception
        }

        String $HOME = System.getProperty("user.home");
        PropertyConfigurator.configure("log4j.properties");
        Common.build("ABOS.conf");

        NetCDFcreateForm form = new NetCDFcreateForm();
        form.initialise();
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private org.imos.abos.dbms.fields.MooringCombo mooringCombo1;
    private org.wiley.util.basicField mooringDescriptionField;
    private javax.swing.JButton quitButton;
    private javax.swing.JButton runButton;
    private org.imos.abos.dbms.fields.InstrumentSelectorCombo sourceInstrumentCombo;
    // End of variables declaration//GEN-END:variables

}
