/*
 * IMOS Data Delivery Project
 * Written by Peter Jansen
 * This code is copyright (c) Peter Jansen 2000 - ?
 * It is made available under the BSD Software Licence in the hope that it may be useful.
 * It has NO WARRANTY OF FITNESS OR SUITABILITY FOR ANY PURPOSE.
 * Feel free to fix any bugs that you may find.
 */

/*
 * NetCDFcreateForm.java
 *
 * Created on 8 June 2013
 */

package org.imos.abos.forms;

import java.awt.Color;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.TimeZone;
import java.util.Vector;
import java.util.logging.Level;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.imos.abos.dbms.Instrument;
import org.imos.abos.dbms.InstrumentCalibrationValue;
import org.imos.abos.dbms.Mooring;
import org.imos.abos.dbms.ParameterCodes;
import org.imos.abos.netcdf.NetCDFfile;
import org.imos.abos.netcdf.NetCDFfile.InstanceCoord;
import org.wiley.core.Common;
import org.wiley.core.forms.MemoryWindow;
import org.wiley.util.SQLWrapper;
import org.wiley.util.StringUtilities;
import ucar.ma2.ArrayByte;
import ucar.ma2.ArrayDouble;
import ucar.ma2.ArrayFloat;
import ucar.ma2.ArrayInt;
import ucar.ma2.DataType;
import ucar.ma2.InvalidRangeException;
import ucar.nc2.Attribute;
import ucar.nc2.Dimension;
import ucar.nc2.NetcdfFileWriter;
import ucar.nc2.Variable;

/**
 *
 * @author peter
 */
public class NetCDFcreateForm extends MemoryWindow
{
    private static Logger logger = Logger.getLogger(NetCDFcreateForm.class.getName());
    protected static SQLWrapper query = new SQLWrapper();
    
    private Mooring selectedMooring = null;
    
    private String authority = "IMOS";
    
    protected TimeZone tz = TimeZone.getTimeZone("UTC");
    protected SimpleDateFormat netcdfDate;
    private Instrument sourceInstrument;
    
    private String selectLimited = "";
//    private String selectLimited = " AND d.instrument_id IN (SELECT instrument_id FROM instrument WHERE make = 'WHOI')";
//    private String selectLimited = " AND source_file_id > 300000";// AND data_timestamp between '2010-06-01' AND '2010-06-10'";
    
    private String table = "processed_instrument_data";
    
    /** Creates new form NetCDFcreateForm */
    public NetCDFcreateForm()
    {
        TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
        netcdfDate = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
        netcdfDate.setTimeZone(tz);
    }
    
    @Override
    public void initialise()
    {
        initComponents();
        
        this.setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        jPanel1 = new javax.swing.JPanel();
        mooringCombo1 = new org.imos.abos.dbms.fields.MooringCombo();
        mooringDescriptionField = new org.wiley.util.basicField();
        authorityCombo = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        sourceInstrumentCombo = new org.imos.abos.dbms.fields.InstrumentSelectorCombo();
        jTextFile = new javax.swing.JTextField();
        jCBraw = new javax.swing.JCheckBox();
        jPanel2 = new javax.swing.JPanel();
        runButton = new javax.swing.JButton();
        quitButton = new javax.swing.JButton();

        setTitle("Create NetCDF Form");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent evt)
            {
                formWindowClosing(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        mooringCombo1.setDescriptionField(mooringDescriptionField);
        mooringCombo1.setOrientation(0);
        mooringCombo1.addPropertyChangeListener(new java.beans.PropertyChangeListener()
        {
            public void propertyChange(java.beans.PropertyChangeEvent evt)
            {
                mooringCombo1PropertyChange(evt);
            }
        });

        mooringDescriptionField.setEnabled(false);

        authorityCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "IMOS", "OS" }));

        jLabel1.setText("Authority");

        sourceInstrumentCombo.setLabel("Source Instrument");
        sourceInstrumentCombo.setOrientation(0);

        jTextFile.setText("Generated File : ");

        jCBraw.setText("Raw Data");
        jCBraw.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jCBrawActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, sourceInstrumentCombo, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 558, Short.MAX_VALUE)
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jPanel1Layout.createSequentialGroup()
                                .add(jLabel1)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(authorityCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                            .add(jPanel1Layout.createSequentialGroup()
                                .add(mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 169, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                .add(18, 18, 18)
                                .add(mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 343, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                        .add(0, 0, Short.MAX_VALUE))
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jTextFile))
                .addContainerGap())
            .add(jPanel1Layout.createSequentialGroup()
                .add(69, 69, 69)
                .add(jCBraw)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(authorityCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(jLabel1))
                        .add(46, 46, 46)
                        .add(mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 21, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .add(18, 18, 18)
                .add(sourceInstrumentCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 26, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(18, 18, 18)
                .add(jCBraw)
                .add(34, 34, 34)
                .add(jTextFile, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(167, 167, 167))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        runButton.setText("Run");
        runButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                runButtonActionPerformed(evt);
            }
        });
        jPanel2.add(runButton);

        quitButton.setText("Quit");
        quitButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                quitButtonActionPerformed(evt);
            }
        });
        jPanel2.add(quitButton);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 300, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 21, Short.MAX_VALUE)
                .add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );

        getAccessibleContext().setAccessibleName("SBE16 Extraction Processing Form");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void quitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitButtonActionPerformed
        cleanup();
    }//GEN-LAST:event_quitButtonActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        cleanup();
    }//GEN-LAST:event_formWindowClosing

    private void runButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runButtonActionPerformed

        selectedMooring = mooringCombo1.getSelectedMooring();
        sourceInstrument = sourceInstrumentCombo.getSelectedInstrument();

        if(selectedMooring == null)
        {
            Common.showMessage(this,"No Mooring Selected","You must select a mooring before running any calculations");
            return;
        }
        
        authority = (String)authorityCombo.getSelectedItem();
        
        final Color bg = runButton.getBackground();
        runButton.setText("Running...");
        runButton.setBackground(Color.RED);
        runButton.setForeground(Color.WHITE);

        Thread worker = new Thread()
        {
            @Override
            public void run()
            {
                SwingUtilities.invokeLater(new Runnable()
                {
                @Override
                    public void run()
                    {
                        runButton.setBackground(bg);
                        runButton.setForeground(Color.BLACK);
                        runButton.setText("Run");
                        repaint();
                        if (sourceInstrument != null)
                        {
                            table = "raw_instrument_data";
                        }
                        if (jCBraw.isSelected())
                        {
                            table = "raw_instrument_data";                            
                        }
                        
                        f = new NetCDFfile();
                        
                        createTimeArray(selectedMooring.getMooringID());
                        createDepthArray(selectedMooring.getMooringID());
                        createCDFFile();                        
                    }
                });
            }
        };

        worker.start();      
        
    }//GEN-LAST:event_runButtonActionPerformed

    private void mooringCombo1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_mooringCombo1PropertyChange
        String propertyName = evt.getPropertyName();
        //logger.debug(evt.getPropertyName());
        if(propertyName.equalsIgnoreCase("MOORING_SELECTED")) 
        {
            Mooring selectedItem = (Mooring) evt.getNewValue();
            ArrayList ins = Instrument.selectDataFilesForMooring(selectedItem.getMooringID());
            sourceInstrumentCombo.setInstrumentDataSet(ins);
        }
    }//GEN-LAST:event_mooringCombo1PropertyChange

    private void jCBrawActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCBrawActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jCBrawActionPerformed

    protected Timestamp mooringOutWaterTime = null;
    protected Timestamp mooringInWaterTime = null;
    
    protected Timestamp dataStartTime = null;
    protected Timestamp dataEndTime = null;

    protected ArrayList<Timestamp> timeArray;    
    
    ArrayList<InstanceCoord> instanceCoords;

    protected void createDepthArray(String mooringID)
    {
        String selectInstrument = "";
        if (sourceInstrument != null)
        {
            selectInstrument = " AND d.instrument_id = " + sourceInstrument.getInstrumentID();
        }
        String SQL =  "SELECT parameter_code, array_agg(instrument_id) AS instruments, array_agg(source) AS source, array_agg(depth) AS depths FROM "
                    + "      (SELECT parameter_code::varchar, d.mooring_id, d.instrument_id, s.instrument_id AS source, avg(depth)::numeric(8,3) AS depth FROM  " + table + " AS d JOIN instrument_data_files AS s ON (source_file_id = datafile_pk) "
                    + "                        JOIN instrument ON (d.instrument_id = instrument.instrument_id) "
                    +         " WHERE d.mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID()) 
                    + selectInstrument + " " + selectLimited
                    + " AND data_timestamp BETWEEN " + StringUtilities.quoteString(Common.getRawSQLTimestamp(dataStartTime)) + " AND " + StringUtilities.quoteString(Common.getRawSQLTimestamp(dataEndTime))
                    + "          GROUP BY parameter_code, d.mooring_id, d.instrument_id, s.instrument_id, make, model, serial_number ORDER BY 1, 2, depth, make, model, serial_number "
                    + "      ) AS a"
                    + "    GROUP BY parameter_code ORDER BY depths";
        
        instanceCoords = new ArrayList<InstanceCoord>();
        logger.debug(SQL);
        query.setConnection(Common.getConnection());
        query.executeQuery(SQL);
        Vector depthSet = NetCDFcreateForm.query.getData();
        
        if (depthSet != null && depthSet.size() > 0)
        {
            for (int i = 0; i < depthSet.size(); i++)
            {
                Vector row = (Vector) depthSet.get(i);
                String param = (String)row.get(0);
                logger.debug("param " + param);
                
                InstanceCoord dc = f.new InstanceCoord();
//                try
                {
                    dc.createParam(param);                                       
                }
//                catch (SQLException ex)
                {
//                    java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                Array instruments = (Array)row.get(1);
                logger.debug("instruments " + instruments);
                Array source = (Array)row.get(2);
                logger.debug("source_instrument " + source);
                try
                {
                    dc.instruments = (Integer[])instruments.getArray();
                    dc.source = (Integer[])source.getArray();                
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                                
                Array depths = (Array)row.get(3);
                logger.debug("depths " + depths);
                try
                {
                    dc.createDepths((BigDecimal[])depths.getArray());
                    
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                instanceCoords.add(dc);
                System.out.println();
            }
        }
        logger.debug("Finished generating depth array, number of params is " + instanceCoords.size());
    }

    protected void createTimeArray(String mooringID)
    {
        timeArray = new ArrayList();
                
        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
        selectedMooring = Mooring.selectByMooringID(mooringID);
        
        mooringInWaterTime = selectedMooring.getTimestampIn();
        mooringOutWaterTime = selectedMooring.getTimestampOut();
        
        Connection conn = Common.getConnection();
        Statement proc = null;
        
        String SQL = "SELECT min(data_timestamp), max(data_timestamp) FROM " + table + " AS d WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID());
        if (sourceInstrument != null)
        {                    
            SQL += " AND instrument_id = " + sourceInstrument.getInstrumentID();
        }
        SQL += selectLimited;

        try
        {
            proc = conn.createStatement();
            conn.setAutoCommit(false);
            proc.execute(SQL);  
            ResultSet results = (ResultSet) proc.getResultSet();
            results.next();
            dataStartTime = results.getTimestamp(1);
            dataEndTime = results.getTimestamp(2);            
        }
        catch (SQLException sqex)
        {
            logger.warn(sqex);
        }

        logger.debug("DataStart " + dataStartTime + " End " + dataEndTime);
        
        tz = TimeZone.getTimeZone("GMT");
        GregorianCalendar cal = (GregorianCalendar) Calendar.getInstance();
        cal.setTimeZone(tz);
        
        cal.setTimeInMillis(mooringOutWaterTime.getTime());
        cal.set(Calendar.MINUTE, 59);
        cal.set(Calendar.SECOND, 59);
        cal.set(Calendar.MILLISECOND, 0);
        java.util.Date mooringOutWaterDate = cal.getTime();        
        
        cal.setTimeInMillis(mooringInWaterTime.getTime());
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        long currentMillis = cal.getTimeInMillis();
        Timestamp currentTimestamp = new Timestamp(currentMillis);
        
        
        if (jCBraw.isSelected())
        {
            SQL = "SELECT DISTINCT(date_trunc('second', data_timestamp))" 
                    + " FROM " + table + " AS d "
                    + " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID());
            
            if (sourceInstrument != null)
            {                    
                SQL += " AND instrument_id = " + sourceInstrument.getInstrumentID();
            }
            SQL += selectLimited;

            SQL += " ORDER BY 1";
            
            try
            {
                proc.execute(SQL);  
                logger.debug("Time Array SQL : " + SQL);
                ResultSet results = (ResultSet) proc.getResultSet();
                while (results.next())
                {
                    currentTimestamp = results.getTimestamp(1);
                    timeArray.add(currentTimestamp);
                }
            }
            catch (SQLException ex)
            {
                logger.warn(ex);
            }
        }
        else
        {
            logger.debug("Starting timestamp is " + currentTimestamp);
            while (currentTimestamp.before(mooringOutWaterDate))
            {
                timeArray.add(new Timestamp(currentMillis));
                currentMillis += 3600000;
                currentTimestamp.setTime(currentMillis);
            }
            timeArray.add(currentTimestamp);
        }
        dataEndTime = currentTimestamp;
        
        logger.debug("Finished generating time array, last timestamp was " + currentTimestamp + "\nTotal Elements: " + timeArray.size());
    }

    protected ArrayList<NetCDFcreateForm.ParamDatum> getDataForParameter(String param, Integer instrumentID)
    {
        ArrayList<NetCDFcreateForm.ParamDatum> set = new ArrayList();
        logger.debug("Searching for data for param " + param + " instrument " + instrumentID);
        String SQL = "SELECT date_trunc('second', data_timestamp)," 
                + " instrument_id,"
                + " depth,"
                + " parameter_code,"
                + " parameter_value,"
                + " quality_code"
                + " FROM " + table + " AS d "
                + " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID())
                + selectLimited
                + " AND parameter_code = " + StringUtilities.quoteString(param)
                + " AND instrument_id = " + instrumentID
                + " AND data_timestamp between "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(dataStartTime))
                + " AND "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(dataEndTime))
                + " ORDER BY data_timestamp"
                ;
        
        // logger.debug(SQL);
        NetCDFcreateForm.query.setConnection(Common.getConnection());
        NetCDFcreateForm.query.executeQuery(SQL);
        Vector dataSet = NetCDFcreateForm.query.getData();
        if (dataSet != null && dataSet.size() > 0)
        {
            for (int i = 0; i < dataSet.size(); i++)
            {
                Vector row = (Vector) dataSet.get(i);
                Timestamp t = (Timestamp) row.get(0);
                Integer ix = ((Number) row.get(1)).intValue();
                Double d = ((Number) row.get(2)).doubleValue();
                String p = (String) row.get(3);
                Double v = ((Number) row.get(4)).doubleValue();
                String q = (String) row.get(5);
                NetCDFcreateForm.ParamDatum dd = new NetCDFcreateForm.ParamDatum(t, ix, p, d, v, q);
                set.add(dd);
            }
            logger.debug("Found " + dataSet.size() + " records for instrument " + instrumentID);
            
            return set;
        }
        
        logger.debug("Found 0 records for pressure data for depth " + instrumentID);
        return null;
    }

    HashMap<String, ArrayList<InstanceCoord>> dimensionCoords = new HashMap();

    protected void writeInstanceCoordinateVariableAttributes()
    {
        for(ArrayList<InstanceCoord> dc : dimensionCoords.values())
        {
            InstanceCoord ic = dc.get(0);
            ic.dimVar.addAttribute(new Attribute("units", "meters"));
            String comment = null;
            if (ic.useHeight)
            {
                ic.dimVar.addAttribute(new Attribute("standard_name", "height"));
                ic.dimVar.addAttribute(new Attribute("long_name", "nominal height of each sensor"));
                ic.dimVar.addAttribute(new Attribute("positive", "up"));                
                comment = "height for parameter ";
            }
            else
            {
                ic.dimVar.addAttribute(new Attribute("standard_name", "depth"));
                ic.dimVar.addAttribute(new Attribute("long_name", "nominal depth of each sensor"));
                ic.dimVar.addAttribute(new Attribute("positive", "down"));
                ic.dimVar.addAttribute(new Attribute("comment", "These are nominal values. Use PRES to derive time-varying depths of instruments, as the mooring may tilt in ambient currents."));
                comment = "depths for parameter ";
            }
            ic.dimVar.addAttribute(new Attribute("axis", "Z"));
            ic.dimVar.addAttribute(new Attribute("reference", "sea_level"));
            ic.dimVar.addAttribute(new Attribute("valid_min", 0.0f));
            ic.dimVar.addAttribute(new Attribute("valid_max", 5000.0f));
            for(int i=0;i<dc.size();i++)                
            {
                InstanceCoord icp = dc.get(i);
                comment += icp.params.trim();
                if (i < dc.size()-1)
                {
                    comment += " ";
                }
            }
            ic.dimVar.addAttribute(new Attribute("params", comment));
        }
    }
        
    NetCDFfile f = null;

    protected void createCDFFile()
    {
        selectedMooring.getFacility();
        
        f.setAuthority(authority);
        f.setMooring(selectedMooring);
        f.setFacility(selectedMooring.getFacility());

        String filename = f.getFileName(sourceInstrument, dataStartTime, dataEndTime, table);
        int RECORD_COUNT = timeArray.size();
        try
        {
            // Create new netcdf-3 file with the given filename
            f.createFile(filename);

            f.addGroupAttribute(null, new Attribute("time_deployment_start", netcdfDate.format(mooringInWaterTime)));
            f.addGroupAttribute(null, new Attribute("time_deployment_end", netcdfDate.format(mooringOutWaterTime)));
            
            // Set the file_version, not sure how we're going to do Derived product?
            if (table.startsWith("raw"))
            {   
                f.addGroupAttribute(null, new Attribute("file_version", "Level 0 - RAW data "));                
            }
            else
            {
                f.addGroupAttribute(null, new Attribute("file_version", "Level 1 - Quality Controlled data "));                                
            }
            
            f.writeGlobalAttributes();

            f.addGroupAttribute(null, new Attribute("time_coverage_start", netcdfDate.format(dataStartTime)));
            f.addGroupAttribute(null, new Attribute("time_coverage_end", netcdfDate.format(dataEndTime)));
            
            // Define the coordinate variables.
            // Add TIME coordinate
            f.createCoordinateVariables(timeArray.size());
            f.writeCoordinateVariables(timeArray);
            
            // Add Depth coords
            ArrayList<InstanceCoord> sameDepths = null;
            
            for(InstanceCoord dc : instanceCoords)
            {  
                String depths = Arrays.toString(dc.depths).trim(); 
                if (dimensionCoords.containsKey(depths))
                {
                    sameDepths.add(dc);
                }
                else
                {
                    sameDepths = new ArrayList();
                    sameDepths.add(dc);
                    dimensionCoords.put(depths, sameDepths);
                }                        
            }
            
            int dimNo = 1;
            ArrayList <String>dimNames = new ArrayList<String>();
            
            for (ArrayList<InstanceCoord> sameD : dimensionCoords.values())
            {
                Collections.sort(sameD, new Comparator<InstanceCoord>() 
                {
                        @Override
                        public int compare(InstanceCoord  i1, InstanceCoord  i2)
                        {

                            return  i1.params.compareTo(i2.params);
                        }
                });
                
                String dimensionName = "DEPTH";
                if (sameD.get(0).useHeight)
                {
                    dimensionName = "HEIGHT";
                }
                if (dimensionCoords.size() > 1)
                {
                    for(InstanceCoord dc : sameD)
                    {
                        dimensionName += "_" + dc.params.substring(0, 2);
                    }
                    
                }
                String origName = dimensionName;
                dimNo = 1;
                while (dimNames.contains(dimensionName))
                {
                	dimensionName = origName + "_" + dimNo;
                	dimNo++;
                }
                dimNames.add(dimensionName);
                
                logger.debug("Create Dimension " + dimensionName);
                
                Dimension dim = f.dataFile.addDimension(null, dimensionName, sameD.get(0).depths.length);
                ArrayList<Dimension> dimList = new ArrayList<Dimension>();
                dimList.add(dim);
                
                Variable dimVar = f.dataFile.addVariable(null, dimensionName, DataType.FLOAT, dimList);
                ArrayFloat.D1 dimData = new ArrayFloat.D1(dim.getLength());
                
                for (int i=0;i<sameD.get(0).depths.length;i++)
                {
                    float currentDepth = sameD.get(0).depths[i].floatValue();                        
                    if (sameD.get(0).useHeight)
                    {
                        currentDepth = currentDepth * -1;
                        if (Math.abs(currentDepth) < 0.01)
                            currentDepth = 0.00f;
                        
                        dimData.set(i, currentDepth);
                    }
                    else
                    {
                        dimData.set(i, currentDepth);                        
                    }
                }

                logger.debug("Create Dimension " + dimensionName + " " + f.timeDim.getLength() + " x " + dim.getLength());
                ArrayList dims = new ArrayList();
                if (f.fileOrderTimeDepth)
                {
                	dims.add(f.timeDim);
                	dims.add(dim);
                }
                else
                {
                	dims.add(dim);
                	dims.add(f.timeDim);
                }
                
                for(InstanceCoord ic : sameD)
                {
                    ic.dim = dim;
                    ic.dimVar = dimVar;
                    ic.dimData = dimData;

                    ic.timeAndDim = dims;
                    ic.dimensionName = dimensionName;
                }                
            }

            //
            // got to add the variables before you can write their attributes
            //
            f.writeCoordinateVariableAttributes();
            writeInstanceCoordinateVariableAttributes();
            
            for (InstanceCoord ic : instanceCoords)
            {                
                ic.createVariables();
                
                //for (int p=0;p<ic.params.length;p++)
                {
                    String pt = ic.createParams(RECORD_COUNT);
                    for (int d=0;d<ic.instruments.length;d++)
                    {
                        ArrayList<ParamDatum> masterSet = getDataForParameter(pt, ic.instruments[d]);
                        if (masterSet != null && masterSet.size() > 0)
                        {
                            logger.debug("Processing instrument/parameter " + pt + " at depth " + masterSet.get(0).depth + " size " + masterSet.size());

                            int record = 0;
                            int matchedElements = 0;
                            Double value;
                            for (int setSize = 0; setSize < masterSet.size(); setSize++)
                            {
                                Timestamp currentTime = timeArray.get(record);
                                ParamDatum currentValue = masterSet.get(setSize);
                                while (currentTime.before(currentValue.ts))
                                {
                                    currentTime = timeArray.get(++record);
                                }
                                //logger.debug("timestamp " + currentTime + " " + currentValue.ts);
                                if (currentValue.ts.equals(currentTime))
                                {
                                    matchedElements++;
                                    value = currentValue.val;
                                    if (f.fileOrderTimeDepth)
                                    {
                                    	ic.dataVar.set(record, d, value.floatValue());
                                    }
                                    else
                                    {
                                    	ic.dataVar.set(d, record, value.floatValue());
                                    }
                                    byte b = 0;
                                    if (table.startsWith("raw"))
                                    {
                                        if (currentTime.after(mooringInWaterTime) && currentTime.before(mooringOutWaterTime))
                                        {
                                            b = 0;                                            
                                        }
                                        else
                                        {
                                            b = 4;
                                        }
                                    }
                                    else
                                    {
                                        if (currentValue.quality.trim().equals("RAW"))
                                        {
                                            b = 1;
                                        }
                                        else if ((currentValue.quality.trim().equals("DERIVED")) || (currentValue.quality.trim().equals("EXTRACTED")))
                                        {
                                            b = 1;
                                        }
                                        else if (currentValue.quality.trim().equals("AVG"))
                                        {
                                            b = 1;
                                        }
                                        else if (currentValue.quality.trim().equals("INTERPOLATED"))
                                        {
                                            b = 1;
                                        }
                                        else if (currentValue.quality.trim().equals("BAD"))
                                        {
                                            b = 4;
                                        }
                                    }
                                    if (f.fileOrderTimeDepth)
                                    {
                                    	ic.dataVarQC.set(record, d, b);                                    	
                                    }
                                    else
                                    {
                                    	ic.dataVarQC.set(d, record, b);
                                    }
                                }
                                //record++;                                                
                            }
                           logger.debug("Matched " + matchedElements + " records for " + pt);
                        }
                    }                    
                }
            }
            //Create the file. At this point the (empty) file will be written to disk
            f.create();
            
            // this is a problem as only unique dims need adding
            for(ArrayList<InstanceCoord> dc : dimensionCoords.values())
            {
                InstanceCoord ic = dc.get(0);
                
                f.dataFile.write(ic.dimVar, ic.dimData);
            }
            f.dataFile.write(f.vTime, f.times);

            f.writePosition(selectedMooring.getLatitudeIn(), selectedMooring.getLongitudeIn());
            
            for(InstanceCoord dc : instanceCoords)
            {
                f.dataFile.write(dc.var, dc.dataVar);
                f.dataFile.write(dc.varQC, dc.dataVarQC);
            }
            
            System.out.println("*** SUCCESS writing file " + filename);
        
            jTextFile.setText("Generated File : " + filename);
        }
        catch (IOException e)
        {
            e.printStackTrace(System.err);
        }
        catch (InvalidRangeException e)
        {
            e.printStackTrace(System.err);
        }
//        finally
//        {
//            if (f.dataFile != null)
//            {
//                try
//                {
//                    f.dataFile.close();
//                }
//                catch (IOException ioe)
//                {
//                    ioe.printStackTrace();
//                }
//            }
//        }
        try
		{
			f.dataFile.close();
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }

    protected class ParamDatum
    {
        public Timestamp ts;
        public Integer instrumentID;
        public String paramCode;
        public Double depth;
        public Double val;
        public String quality;

        public ParamDatum()
        {
            super();
        }

        public ParamDatum(Timestamp t, Integer i, String p, Double d, Double v, String q)
        {
            super();
            ts = t;
            instrumentID = i;
            paramCode = p.trim();
            depth = d;
            val = v;
            quality = q;
        }
    }
    
    
    /**
    * @param args the command line arguments
    */
    public static void main(String[] args)
    {
        try
        {
	    // Set cross-platform Java L&F (also called "Metal")
            UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
        }
        catch (UnsupportedLookAndFeelException e)
        {
           // handle exception
        }
        catch (ClassNotFoundException e)
        {
           // handle exception
        }
        catch (InstantiationException e)
        {
           // handle exception
        }
        catch (IllegalAccessException e)
        {
           // handle exception
        }

        String $HOME = System.getProperty("user.home");
        PropertyConfigurator.configure("log4j.properties");
        Common.build($HOME + "/ABOS/ABOS.properties");
        
        NetCDFcreateForm form = new NetCDFcreateForm();
        form.setLocationRelativeTo(null);
        form.initialise();
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox authorityCombo;
    private javax.swing.JCheckBox jCBraw;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JTextField jTextFile;
    private org.imos.abos.dbms.fields.MooringCombo mooringCombo1;
    private org.wiley.util.basicField mooringDescriptionField;
    private javax.swing.JButton quitButton;
    private javax.swing.JButton runButton;
    private org.imos.abos.dbms.fields.InstrumentSelectorCombo sourceInstrumentCombo;
    // End of variables declaration//GEN-END:variables

}
