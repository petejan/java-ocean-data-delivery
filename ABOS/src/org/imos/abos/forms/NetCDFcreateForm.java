/*
 * IMOS Data Delivery Project
 * Written by Peter Jansen
 * This code is copyright (c) Peter Jansen 2000 - ?
 * It is made available under the BSD Software Licence in the hope that it may be useful.
 * It has NO WARRANTY OF FITNESS OR SUITABILITY FOR ANY PURPOSE.
 * Feel free to fix any bugs that you may find.
 */

/*
 * NetCDFcreateForm.java
 *
 * Created on 8 June 2013
 */

package org.imos.abos.forms;

import java.awt.Color;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TimeZone;
import java.util.Vector;
import java.util.logging.Level;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.imos.abos.dbms.Instrument;
import org.imos.abos.dbms.InstrumentCalibrationValue;
import org.imos.abos.dbms.InstrumentDataFile;
import org.imos.abos.dbms.Mooring;
import org.imos.abos.dbms.ParameterCodes;
import org.imos.abos.netcdf.NetCDFfile;
import org.imos.abos.netcdf.NetCDFfile.InstanceCoord;
import org.wiley.core.Common;
import org.wiley.core.forms.MemoryWindow;
import org.wiley.util.SQLWrapper;
import org.wiley.util.StringUtilities;
import ucar.ma2.ArrayByte;
import ucar.ma2.ArrayDouble;
import ucar.ma2.ArrayFloat;
import ucar.ma2.ArrayInt;
import ucar.ma2.DataType;
import ucar.ma2.Index;
import ucar.ma2.InvalidRangeException;
import ucar.nc2.Attribute;
import ucar.nc2.Dimension;
import ucar.nc2.NetcdfFileWriter;
import ucar.nc2.Variable;

/**
 *
 * @author peter
 */
public class NetCDFcreateForm extends MemoryWindow
{
	private static Logger logger = Logger.getLogger(NetCDFcreateForm.class.getName());
	protected static SQLWrapper query = new SQLWrapper();

	protected Mooring selectedMooring = null;

	private String authority = "IMOS";

	protected TimeZone tz = TimeZone.getTimeZone("UTC");
	protected SimpleDateFormat netcdfDate;
	protected Instrument dataForInstrument;
	protected InstrumentDataFile sourceFile;

	protected String selectLimited = "";

	private HashMap<String, String> limitList = new HashMap<String, String>();
	private ArrayList<String> instList = new ArrayList<String>();

	protected String table = "processed_instrument_data";

	protected String appendInstrument = null;

	/** Creates new form NetCDFcreateForm */
	public NetCDFcreateForm()
	{
		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
		netcdfDate = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");

		netcdfDate.setTimeZone(tz);

		limitList.put("", "");
		limitList.put("ASIMET", " AND d.instrument_id IN (SELECT instrument_id FROM instrument WHERE make = 'WHOI')");
		limitList.put("INST", " AND quality_code not 'INTERPOLATED'");

		instList.add(null);
		instList.add("Gridded Data");
		instList.add("subsurface");
		
		//sourceFile = InstrumentDataFile.selectByInstrumentDataFileID(200485);
	}

	@Override
	public void initialise()
	{
		initComponents();

		this.setVisible(true);
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents()
	{

		jPanel1 = new javax.swing.JPanel();
		mooringCombo1 = new org.imos.abos.dbms.fields.MooringCombo();
		mooringDescriptionField = new org.wiley.util.basicField();
		authorityCombo = new javax.swing.JComboBox();
		limitCombo = new javax.swing.JComboBox();
		instCombo = new javax.swing.JComboBox();
		instCombo.setEditable(true);
		jLabel1 = new javax.swing.JLabel();
		sourceInstrumentCombo = new org.imos.abos.dbms.fields.InstrumentSelectorCombo();
		jTextFile = new javax.swing.JTextField();
		jCBraw = new javax.swing.JCheckBox();
		jPanel2 = new javax.swing.JPanel();
		runButton = new javax.swing.JButton();
		quitButton = new javax.swing.JButton();

		setTitle("Create NetCDF Form");
		addWindowListener(new java.awt.event.WindowAdapter()
		{
			public void windowClosing(java.awt.event.WindowEvent evt)
			{
				formWindowClosing(evt);
			}
		});

		jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

		mooringCombo1.setDescriptionField(mooringDescriptionField);
		mooringCombo1.setOrientation(0);
		mooringCombo1.addPropertyChangeListener(new java.beans.PropertyChangeListener()
		{
			public void propertyChange(java.beans.PropertyChangeEvent evt)
			{
				mooringCombo1PropertyChange(evt);
			}
		});

		mooringDescriptionField.setEnabled(false);

		authorityCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "IMOS", "OS" }));
		limitCombo.setModel(new javax.swing.DefaultComboBoxModel(limitList.keySet().toArray()));
		instCombo.setModel(new javax.swing.DefaultComboBoxModel(instList.toArray()));

		jLabel1.setText("Authority");

		sourceInstrumentCombo.setLabel("Source Instrument");
		sourceInstrumentCombo.setOrientation(0);

		jTextFile.setText("Generated File : ");

		jCBraw.setText("Raw Data");
		jCBraw.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				jCBrawActionPerformed(evt);
			}
		});

		org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
		jPanel1.setLayout(jPanel1Layout);
		jPanel1Layout.setHorizontalGroup(
				jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(jPanel1Layout.createSequentialGroup()
						.addContainerGap()
						.add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
								.add(org.jdesktop.layout.GroupLayout.TRAILING, sourceInstrumentCombo, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 558, Short.MAX_VALUE)
								.add(org.jdesktop.layout.GroupLayout.TRAILING, limitCombo, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 558, Short.MAX_VALUE)
								.add(org.jdesktop.layout.GroupLayout.TRAILING, instCombo, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 558, Short.MAX_VALUE)
								.add(jPanel1Layout.createSequentialGroup()
										.add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
												.add(jPanel1Layout.createSequentialGroup()
														.add(jLabel1)
														.addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
														.add(authorityCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
												.add(jPanel1Layout.createSequentialGroup()
														.add(mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 169, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
														.add(18, 18, 18)
														.add(mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 343, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
										.add(0, 0, Short.MAX_VALUE))
								.add(org.jdesktop.layout.GroupLayout.TRAILING, jTextFile))
						.addContainerGap())
				.add(jPanel1Layout.createSequentialGroup()
						.add(69, 69, 69)
						.add(jCBraw)
						.addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
				);
		jPanel1Layout.setVerticalGroup(
				jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
						.addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
						.add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
								.add(mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
								.add(jPanel1Layout.createSequentialGroup()
										.add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
												.add(authorityCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
												.add(jLabel1))
										.add(46, 46, 46)
										.add(mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 21, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
						.add(18, 18, 18)
						.add(sourceInstrumentCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 26, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.add(18, 18, 18)
						.add(limitCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 26, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.add(18, 18, 18)
						.add(instCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 26, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.add(18, 18, 18)
						.add(jCBraw)
						.add(34, 34, 34)
						.add(jTextFile, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.add(167, 167, 167))
				);

		jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

		runButton.setText("Run");
		runButton.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				runButtonActionPerformed(evt);
			}
		});
		jPanel2.add(runButton);

		quitButton.setText("Quit");
		quitButton.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				quitButtonActionPerformed(evt);
			}
		});
		jPanel2.add(quitButton);

		org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(layout.createSequentialGroup()
						.addContainerGap()
						.add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
								.add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
								.add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
						.addContainerGap())
				);
		layout.setVerticalGroup(
				layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(layout.createSequentialGroup()
						.addContainerGap()
						.add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 300, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 21, Short.MAX_VALUE)
						.add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
				);

		getAccessibleContext().setAccessibleName("NetCDF create form");

		pack();
	}// </editor-fold>//GEN-END:initComponents

	private void quitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitButtonActionPerformed
		cleanup();
	}//GEN-LAST:event_quitButtonActionPerformed

	private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
		cleanup();
	}//GEN-LAST:event_formWindowClosing

	private void runButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runButtonActionPerformed

		if (instanceCoords != null)
			instanceCoords.clear();
		if (timeArray != null)
			timeArray.clear();
		//if (dimensionCoords != null)
		//dimensionCoords.clear();

		selectedMooring = mooringCombo1.getSelectedMooring();
		dataForInstrument = sourceInstrumentCombo.getSelectedInstrument();
		selectLimited = limitList.get(limitCombo.getSelectedItem());

		if(selectedMooring == null)
		{
			Common.showMessage(this,"No Mooring Selected","You must select a mooring before running any calculations");
			return;
		}

		authority = (String)authorityCombo.getSelectedItem();

		final Color bg = runButton.getBackground();
		runButton.setText("Running...");
		runButton.setBackground(Color.RED);
		runButton.setForeground(Color.WHITE);

		Thread worker = new Thread()
		{
			@Override
			public void run()
			{
				SwingUtilities.invokeLater(new Runnable()
				{
					@Override
					public void run()
					{
						runButton.setBackground(bg);
						runButton.setForeground(Color.BLACK);
						runButton.setText("Run");
						repaint();
						//                        if (sourceInstrument != null)
						//                        {
						//                            table = "raw_instrument_data";
						//                        }
						if (jCBraw.isSelected())
						{
							table = "raw_instrument_data";                            
						}

						f = new NetCDFfile();

						appendInstrument = (String)instCombo.getSelectedItem();
						createTimeArray(selectedMooring.getMooringID());
						createDepthArray(selectedMooring.getMooringID());
						createCDFFile();       

						jTextFile.setText("Generated File : " + filename);

					}
				});
			}
		};

		worker.start();      

	}//GEN-LAST:event_runButtonActionPerformed

	private void mooringCombo1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_mooringCombo1PropertyChange
		String propertyName = evt.getPropertyName();
		//logger.debug(evt.getPropertyName());
		if(propertyName.equalsIgnoreCase("MOORING_SELECTED")) 
		{
			Mooring selectedItem = (Mooring) evt.getNewValue();
			ArrayList ins = Instrument.selectDataFilesForMooring(selectedItem.getMooringID());
			sourceInstrumentCombo.setInstrumentDataSet(ins);
		}
	}//GEN-LAST:event_mooringCombo1PropertyChange

	private void jCBrawActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCBrawActionPerformed
		// TODO add your handling code here:
	}//GEN-LAST:event_jCBrawActionPerformed

	protected Timestamp mooringOutWaterTime = null;
	protected Timestamp mooringInWaterTime = null;

	protected Timestamp dataStartTime = null;
	protected Timestamp dataEndTime = null;

	protected ArrayList<Timestamp> timeArray;    

	protected ArrayList<InstanceCoord> instanceCoords;

	protected HashSet<BigDecimal> allDepths = new HashSet<BigDecimal>();

	protected void createDepthArray(String mooringID)
	{
		String selectInstrument = "";
		if (dataForInstrument != null)
		{
			selectInstrument = " AND d.instrument_id = " + dataForInstrument.getInstrumentID();
		}
		if (sourceFile != null)
		{
			selectInstrument = " AND d.source_file_id = " + sourceFile.getDataFilePrimaryKey();
		}
		logger.debug("dataStart " + dataStartTime + " dataEnd " + dataEndTime);

		//    SELECT parameter_code, imos_data_code, array_agg(instrument_id) AS instruments, array_agg(source) AS source, array_agg(depth) AS depths 
		//    	FROM       
		//    		(
		//    			SELECT CAST(parameter_code AS varchar(20)), imos_data_code , d.mooring_id, d.instrument_id, min(s.instrument_id) AS source, CAST(avg(depth) AS numeric(8,3)) AS depth 
		//    				FROM  processed_instrument_data AS d 
		//    				JOIN instrument_data_files AS s ON (source_file_id = datafile_pk)                         
		//    				JOIN instrument ON (d.instrument_id = instrument.instrument_id)                         
		//    				JOIN parameters ON (d.parameter_code = parameters.code) 
		//    			  WHERE 
		//    				d.mooring_id = 'Pulse-11-2015' AND quality_code not in ('BAD')   
		//    				AND data_timestamp BETWEEN '2015-02-13 07:00:00' AND '2016-04-03 05:00:00'          
		//    			  GROUP BY parameter_code, imos_data_code, d.mooring_id, d.instrument_id, make, model, serial_number 
		//    			  ORDER BY 1, 2, depth, make, model, serial_number 
		//    		) AS a    
		//    	GROUP BY parameter_code, imos_data_code 
		//    	ORDER BY depths, parameter_code        

		String SQL =  "SELECT parameter_code, imos_data_code, array_agg(instrument_id) AS instruments, array_agg(source) AS source, array_agg(depth) AS depths FROM "
				+ "      (SELECT CAST(parameter_code AS varchar(20)), imos_data_code , d.mooring_id, d.instrument_id, min(s.instrument_id) AS source, CAST(avg(depth) AS numeric(8,3)) AS depth FROM  " + table + " AS d JOIN instrument_data_files AS s ON (source_file_id = datafile_pk) "
				+ "                        JOIN instrument ON (d.instrument_id = instrument.instrument_id) "
				+ "                        JOIN parameters ON (d.parameter_code = parameters.code)"
				+         " WHERE d.mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID()) + " AND quality_code not in ('INTERPOLATED', 'BAD') "
				//+         " WHERE d.mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID()) + " AND quality_code not in ('BAD') "
				+ selectInstrument + " " + selectLimited
				+ " AND data_timestamp BETWEEN " + StringUtilities.quoteString(Common.getRawSQLTimestamp(dataStartTime)) + " AND " + StringUtilities.quoteString(Common.getRawSQLTimestamp(dataEndTime))
				+ "          GROUP BY parameter_code, imos_data_code, d.mooring_id, d.instrument_id, make, model, serial_number ORDER BY 1, 2, depth, make, model, serial_number "
				+ "      ) AS a"
				+ "    GROUP BY parameter_code, imos_data_code ORDER BY depths, parameter_code";

		instanceCoords = new ArrayList<InstanceCoord>();
		logger.debug(SQL);
		query.setConnection(Common.getConnection());
		query.executeQuery(SQL);
		Vector depthSet = query.getData();

		if (depthSet != null && depthSet.size() > 0)
		{
			for (int i = 0; i < depthSet.size(); i++)
			{
				Vector row = (Vector) depthSet.get(i);
				String param = (String)row.get(0);
				String imos_data_code = (String)row.get(1);
				logger.debug("param " + param + " data_code " + imos_data_code);

				InstanceCoord dc = f.new InstanceCoord();
				dc.createParam(param, imos_data_code);

				Array instruments = (Array)row.get(2);
				logger.debug("instruments " + instruments);
				Array source = (Array)row.get(3);
				logger.debug("source_instrument " + source);

				try
				{
					dc.instruments = (Integer[])instruments.getArray();
					dc.source = (Integer[])source.getArray();                
				}
				catch (SQLException ex)
				{
					java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
				}

				Array depths = (Array)row.get(4);
				logger.debug("depths " + depths);

				try
				{
					BigDecimal[] d = (BigDecimal[])depths.getArray();

					dc.createDepths(d);
					for (int i1=0;i1<d.length;i1++)
					{
						allDepths.add(d[i1]);
					}
				}
				catch (SQLException ex)
				{
					java.util.logging.Logger.getLogger(NetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
				}
				instanceCoords.add(dc);
			}
		}
		logger.debug("Finished generating depth array, number of params is " + instanceCoords.size() + " n depths " + allDepths.size());
	}

	protected void createTimeArray(String mooringID)
	{
		timeArray = new ArrayList<Timestamp>();

		TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
		selectedMooring = Mooring.selectByMooringID(mooringID);

		mooringInWaterTime = selectedMooring.getTimestampIn();
		mooringOutWaterTime = selectedMooring.getTimestampOut();

		Connection conn = Common.getConnection();
		Statement proc = null;

		String SQL = "SELECT min(data_timestamp), max(data_timestamp) FROM " + table + " AS d WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID());
		if (dataForInstrument != null)
		{                    
			SQL += " AND instrument_id = " + dataForInstrument.getInstrumentID();
		}
		if (sourceFile != null)
		{                    
			SQL += " AND source_file_id = " + sourceFile.getDataFilePrimaryKey();
		}
		SQL += selectLimited;

		try
		{
			proc = conn.createStatement();
			conn.setAutoCommit(false);
			logger.debug("SQL " + SQL);
			proc.execute(SQL);  
			ResultSet results = (ResultSet) proc.getResultSet();
			results.next();
			dataStartTime = results.getTimestamp(1);
			dataEndTime = results.getTimestamp(2);            
		}
		catch (SQLException sqex)
		{
			logger.warn(sqex);
		}

		logger.debug("DataStart " + dataStartTime + " End " + dataEndTime);

		Timestamp currentTimestamp = null;

		SQL = "SELECT DISTINCT(data_timestamp)" 
				+ " FROM " + table + " AS d "
				+ " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID());

		if (dataForInstrument != null)
		{                    
			SQL += " AND instrument_id = " + dataForInstrument.getInstrumentID();
		}
		SQL += selectLimited;

		SQL += " ORDER BY 1";

		try
		{
			proc.execute(SQL);  
			logger.debug("Time Array SQL : " + SQL);
			ResultSet results = (ResultSet) proc.getResultSet();
			while (results.next())
			{
				currentTimestamp = results.getTimestamp(1);
				timeArray.add(currentTimestamp);
			}
		}
		catch (SQLException ex)
		{
			logger.warn(ex);
		}

		dataEndTime = currentTimestamp;

		logger.debug("Finished generating time array, last timestamp was " + currentTimestamp + "\nTotal Elements: " + timeArray.size());
	}

	protected ArrayList<NetCDFcreateForm.ParamDatum> getDataForParameter(String param, Integer instrumentID)
	{
		ArrayList<NetCDFcreateForm.ParamDatum> set = new ArrayList();
		logger.debug("Searching for data for param " + param + " instrument " + instrumentID);
		String SQL = "SELECT date_trunc('second', data_timestamp)," 
				+ " instrument_id,"
				+ " depth,"
				+ " parameter_code,"
				+ " CAST(parameter_value AS double precision),"
				+ " quality_code"
				+ " FROM " + table + " AS d "
				+ " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID())
				+ selectLimited
				+ " AND parameter_code = " + StringUtilities.quoteString(param)
				+ " AND instrument_id = " + instrumentID
				+ " AND data_timestamp between "
				+ StringUtilities.quoteString(Common.getRawSQLTimestamp(dataStartTime))
				+ " AND "
				+ StringUtilities.quoteString(Common.getRawSQLTimestamp(dataEndTime))
				+ " ORDER BY data_timestamp"
				;

		//logger.debug(SQL);
		NetCDFcreateForm.query.setConnection(Common.getConnection());
		NetCDFcreateForm.query.executeQuery(SQL);
		Vector dataSet = NetCDFcreateForm.query.getData();
		if (dataSet != null && dataSet.size() > 0)
		{
			for (int i = 0; i < dataSet.size(); i++)
			{
				Vector row = (Vector) dataSet.get(i);
				Timestamp t = (Timestamp) row.get(0);
				Integer ix = ((Number) row.get(1)).intValue();
				Double d = ((Number) row.get(2)).doubleValue();
				String p = (String) row.get(3);
				Double v = ((Number) row.get(4)).doubleValue();
				String q = (String) row.get(5);
				NetCDFcreateForm.ParamDatum dd = new NetCDFcreateForm.ParamDatum(t, ix, p, d, v, q);
				set.add(dd);
			}
			logger.debug("Found " + dataSet.size() + " records for instrument " + instrumentID);

					return set;
		}

		logger.debug("Found 0 records for pressure data for depth " + instrumentID);
		return null;
	}

	//HashMap<String, ArrayList<InstanceCoord>> dimensionCoords = new HashMap();
	//ArrayList<String, ArrayList<InstanceCoord>> dimensionCoords = new ArrayList();

	protected void writeInstanceCoordinateVariableAttributes()
	{
		//for(ArrayList<InstanceCoord> dc : dimensionCoords.values())
		for (InstanceCoord ic : instanceCoords)
		{
			//InstanceCoord ic = dc.get(0);
			logger.debug("writeInstanceCoordinateVariableAttributes:: depthVariable : " + ic.depthVariable.getShortName());
			
			ic.depthVariable.addAttribute(new Attribute("units", "meters"));
			String comment = null;
			if (ic.useHeight)
			{
				ic.depthVariable.addAttribute(new Attribute("standard_name", "height"));
				ic.depthVariable.addAttribute(new Attribute("long_name", "nominal height of each variable"));
				ic.depthVariable.addAttribute(new Attribute("positive", "up"));                
				comment = "height for parameter ";
			}
			else
			{
				ic.depthVariable.addAttribute(new Attribute("standard_name", "depth"));
				ic.depthVariable.addAttribute(new Attribute("long_name", "nominal depth of each variable"));
				ic.depthVariable.addAttribute(new Attribute("positive", "down"));
				//ic.dimVar.addAttribute(new Attribute("comment", "These are nominal values. Use PRES to derive time-varying depths of instruments, as the mooring may tilt in ambient currents."));
				comment = "depths for parameter ";
			}
			ic.depthVariable.addAttribute(new Attribute("axis", "Z"));
			ic.depthVariable.addAttribute(new Attribute("reference_datum", "Mean Sea Level (MSL)")); // TODO: should this be sea surface heights for float sensors?
			ic.depthVariable.addAttribute(new Attribute("valid_min", 0.0f));
			ic.depthVariable.addAttribute(new Attribute("valid_max", 5000.0f));

			//comment += ic.params.trim();
			//ic.depthVariable.addAttribute(new Attribute("params", comment));
		}
	}

	protected NetCDFfile f = null;
	String filename;

	protected void createCDFFile()
	{
		HashMap<String, Integer> qualityFlag = new HashMap<String, Integer>();
		qualityFlag.put("RAW", 1);
		qualityFlag.put("DERIVED", 1);
		qualityFlag.put("EXTRACTED", 1);
		qualityFlag.put("AVG", 1);
		qualityFlag.put("INTERPOLATED", 8);
		qualityFlag.put("GOOD", 1);
		qualityFlag.put("PGOOD", 2);
		qualityFlag.put("PBAD", 3);
		qualityFlag.put("BAD", 4);
		qualityFlag.put("OOR", 4);
		qualityFlag.put("OUT", 6);
		qualityFlag.put("MISSING", 9);

		selectedMooring.getFacility();

		f.setAuthority(authority);
		f.setMooring(selectedMooring);
		f.setFacility(selectedMooring.getFacility());

		// get imos data file codes
		String dataCodes = "";
		for(InstanceCoord dc : instanceCoords)
		{
			if (!dataCodes.contains(dc.dataCode))
			{
				dataCodes += dc.dataCode;
			}
		}
		Instrument instData = dataForInstrument;
		if (instData == null)
		{
			if (sourceFile != null)
			{
				instData = Instrument.selectByInstrumentID(sourceFile.getInstrumentID());
			}
		}

		filename = f.getFileName(instData, dataStartTime, dataEndTime, table, dataCodes, appendInstrument);

		int RECORD_COUNT = timeArray.size();
		try
		{
			// Create new netcdf-3 file with the given filename
			f.createFile(filename);

			f.addGroupAttribute(null, new Attribute("time_deployment_start", netcdfDate.format(mooringInWaterTime)));
			f.addGroupAttribute(null, new Attribute("time_deployment_end", netcdfDate.format(mooringOutWaterTime)));

			// Set the file_version, not sure how we're going to do Derived product?
			if (table.startsWith("raw"))
			{   
				f.addGroupAttribute(null, new Attribute("file_version", "Level 1 - Quality Controlled Data"));                
			}
			else
			{
				f.addGroupAttribute(null, new Attribute("file_version", "Level 2 - Derived Product"));                                
			}

			f.writeGlobalAttributes();

			f.addGroupAttribute(null, new Attribute("time_coverage_start", netcdfDate.format(dataStartTime)));
			f.addGroupAttribute(null, new Attribute("time_coverage_end", netcdfDate.format(dataEndTime)));

			f.addGroupAttribute(null, new Attribute("history", netcdfDate.format(new Date(System.currentTimeMillis()))+ " file created"));

			// Define the coordinate variables.
			// Add TIME coordinate
			f.createCoordinateVariables(timeArray.size());
			f.writeCoordinateVariables(timeArray);

			// Add Depth coords
			ArrayList <String>dimNames = new ArrayList<String>();
			ArrayList<Dimension> dimListDepth = null;
			ArrayList<Dimension> dims = null;
			Dimension dim = null;
			Variable depthVar = null;
			ArrayFloat.D1 depthData = null;
			String depthVariableName = null;

			for (InstanceCoord ic : instanceCoords)
			{                
				depthVariableName = "DEPTH";
				if (ic.useHeight)
				{
					depthVariableName = "HEIGHT";
				}
				// check if we need to create any more DEPTH variables/INSTANCE dimensions
				float firstDepth = ic.depths[0].floatValue();
				
				boolean moreThanOneDepth = false;
				boolean moreThanOneInstance = false;
				
				for (int i=1;i<ic.depths.length;i++)
				{
					float currentDepth = ic.depths[i].floatValue();
					if (currentDepth != firstDepth)
						moreThanOneDepth = true;
				}
				for(InstanceCoord otherIc: instanceCoords)
				{
					if (otherIc.depths.length > 1)
						moreThanOneInstance = true;
				}
				logger.debug("depths " + ic.depths.length + " more than one depth : " + moreThanOneDepth + " more than one instance : " + moreThanOneInstance);
				
				if (moreThanOneInstance)
				{
					depthVariableName += "_" + ic.params;

					// relabel any duplicates to _<n>
					String origName = depthVariableName;
					int dimNo = 1;
					while (dimNames.contains(depthVariableName))
					{
						depthVariableName = origName + "_" + dimNo;
						dimNo++;
					}
				}
				dimNames.add(depthVariableName);
				logger.debug("Create depth/height variable " + depthVariableName);

				dimListDepth = new ArrayList<Dimension>();
				dims = new ArrayList<Dimension>();
				dim = null;

				// create the dimension in the file, using an INSTANCE dimension instead of DEPTH means the don't need to be in order or distinct.
				
				if (moreThanOneInstance)
				{
					dim = f.dataFile.addDimension(null, "INSTANCE_" + ic.params, ic.depths.length);
					dimListDepth.add(dim);
	
					logger.debug("Create Dimension " + dim.getShortName() + " " + f.timeDim.getLength() + " x " + dim.getLength());
					
					// create a dimension list for this variable
					if (f.fileOrderTimeDepth)
					{
						dims.add(f.timeDim);
						dims.add(dim);
					}
					else
					{
						dims.add(dim);
						dims.add(f.timeDim);
					}
				}
				else
					dims.add(f.timeDim);
				
				if (moreThanOneInstance || depthVar == null)
				{
					logger.debug("Create depth variable " + depthVariableName);
					
					// create the depth/height variable and fill it with the depths
					depthVar = f.dataFile.addVariable(null, depthVariableName, DataType.FLOAT, dimListDepth);
					depthData = new ArrayFloat.D1(ic.depths.length);

					logger.debug("Create depth variable " + depthVariableName + " " + depthVar);
	
					for (int i=0;i<ic.depths.length;i++)
					{
						float currentDepth = ic.depths[i].floatValue();                        
						if (ic.useHeight)
						{
							currentDepth = currentDepth * -1;
							if (Math.abs(currentDepth) < 0.01)
								currentDepth = 0.00f;
						}
						depthData.set(i, currentDepth);
					}
				}

				ic.instanceDim = dim;
				ic.depthVariable = depthVar;
				ic.depthData = depthData;

				ic.timeAndDim = dims;
				ic.depthVariablename = depthVariableName;
			}

			//
			// got to add the variables before you can write their attributes
			//
			f.writeCoordinateVariableAttributes();
			writeInstanceCoordinateVariableAttributes();


			for (InstanceCoord ic : instanceCoords)
			{                
				ic.createVariables();

				//for (int p=0;p<ic.params.length;p++)
				{
					String pt = ic.createVariable(RECORD_COUNT);
					Index idx = ic.dataVar.getIndex();

					for (int d=0;d<ic.instruments.length;d++)
					{
						idx.setDim(ic.depthDim, d);

						ArrayList<ParamDatum> masterSet = getDataForParameter(pt, ic.instruments[d]);
						if (masterSet != null && masterSet.size() > 0)
						{
							logger.debug("Processing instrument/parameter " + pt + " at depth " + masterSet.get(0).depth + " size " + masterSet.size());

							if (pt.contains("DURATION"))
							{
								f.timeBndsOffset = masterSet.get(0).val;
							}
							int matchedElements = 0;
							int record = 0;
							Double value;
							Timestamp currentTime = timeArray.get(record);

							for (int rec = 0; rec < masterSet.size(); rec++)
							{
								ParamDatum currentValue = masterSet.get(rec);

								//logger.debug("Index for " + ic.varName + " idx " + idx + " record " + record + " rec " + rec + " timestamp " + currentTime + " " + currentValue.ts);

								// index to the first time record
								while (currentTime.before(currentValue.ts))
								{
									currentTime = timeArray.get(++record);
								}
								//logger.debug("timestamp " + currentTime + " " + currentValue.ts);

								// do we have data for this timestamp, or should we skip it
								if (currentValue.ts.equals(currentTime))
								{
									matchedElements++;
									value = currentValue.val;
									// apply scale/offset to raw data
									if (table.startsWith("raw"))
									{
										value = value * ic.scale + ic.offset;
									}

									idx.setDim(ic.timeDim, record);

									ic.dataVar.set(idx, value.floatValue());

									// deal with the quality_control
									byte b = 0;
//									if (currentTime.before(mooringInWaterTime) || currentTime.after(mooringOutWaterTime))
//									{
//										b = 5;                                            
//									}
//									else
									{
										Integer qf = qualityFlag.get(currentValue.quality.trim());
										logger.trace("Quality Flag : " + currentValue.quality.trim() + " " + qf);
										if (qf != null)
											b = qf.byteValue();
									}
									
									ic.dataVarQC.set(idx, b);
								}
								//record++;                                                
							}
							logger.debug("Matched " + matchedElements + " records for " + pt);
						}
					}                    
				}
			}
			//Create the file. At this point the (empty) file will be written to disk
			f.create();

			// this is a problem as only unique dims need adding
			//for(ArrayList<InstanceCoord> dc : dimensionCoords.values())
			for(InstanceCoord ic : instanceCoords)
			{
				//InstanceCoord ic = dc.get(0);

				f.dataFile.write(ic.depthVariable, ic.depthData);
			}
			f.dataFile.write(f.vTime, f.times);

			f.writePosition(selectedMooring.getLatitudeIn(), selectedMooring.getLongitudeIn());

			for(InstanceCoord dc : instanceCoords)
			{
				f.dataFile.write(dc.var, dc.dataVar);
				f.dataFile.write(dc.varQC, dc.dataVarQC);
			}

			System.out.println("*** SUCCESS writing file " + filename);
		}
		catch (IOException e)
		{
			e.printStackTrace(System.err);
		}
		catch (InvalidRangeException e)
		{
			e.printStackTrace(System.err);
		}
		//        finally
		//        {
		//            if (f.dataFile != null)
		//            {
		//                try
		//                {
		//                    f.dataFile.close();
		//                }
		//                catch (IOException ioe)
		//                {
		//                    ioe.printStackTrace();
		//                }
		//            }
		//        }
		try
		{
			f.dataFile.close();
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	protected class ParamDatum
	{
		public Timestamp ts;
		public Integer instrumentID;
		public String paramCode;
		public Double depth;
		public Double val;
		public String quality;

		public ParamDatum()
		{
			super();
		}

		public ParamDatum(Timestamp t, Integer i, String p, Double d, Double v, String q)
		{
			super();
			ts = t;
			instrumentID = i;
			paramCode = p.trim();
			depth = d;
			val = v;
			quality = q;
		}
	}


	/**
	 * @param args the command line arguments
	 */
	public static void main(String[] args)
	{
		try
		{
			// Set cross-platform Java L&F (also called "Metal")
			UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
		}
		catch (UnsupportedLookAndFeelException e)
		{
			// handle exception
		}
		catch (ClassNotFoundException e)
		{
			// handle exception
		}
		catch (InstantiationException e)
		{
			// handle exception
		}
		catch (IllegalAccessException e)
		{
			// handle exception
		}

		String $HOME = System.getProperty("user.home");
		PropertyConfigurator.configure("log4j.properties");
		Common.build("ABOS.properties");

		NetCDFcreateForm form = new NetCDFcreateForm();
		form.setLocationRelativeTo(null);
		form.initialise();
	}


	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JComboBox authorityCombo;
	private javax.swing.JComboBox limitCombo;
	private javax.swing.JComboBox instCombo;
	private javax.swing.JCheckBox jCBraw;
	private javax.swing.JLabel jLabel1;
	private javax.swing.JPanel jPanel1;
	private javax.swing.JPanel jPanel2;
	private javax.swing.JTextField jTextFile;
	private org.imos.abos.dbms.fields.MooringCombo mooringCombo1;
	private org.wiley.util.basicField mooringDescriptionField;
	private javax.swing.JButton quitButton;
	private javax.swing.JButton runButton;
	private org.imos.abos.dbms.fields.InstrumentSelectorCombo sourceInstrumentCombo;
	// End of variables declaration//GEN-END:variables

}
