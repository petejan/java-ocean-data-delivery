/*
 * IMOS Data Delivery Project
 * Written by Peter Jansen
 * This code is copyright (c) Peter Jansen 2000 - ?
 * It is made available under the BSD Software Licence in the hope that it may be useful.
 * It has NO WARRANTY OF FITNESS OR SUITABILITY FOR ANY PURPOSE.
 * Feel free to fix any bugs that you may find.
 */

/*
 * NetCDFcreateForm.java
 *
 * Created on 8 June 2013
 */

package org.imos.abos.forms;

import java.awt.Color;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.TimeZone;
import java.util.Vector;
import java.util.logging.Level;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.imos.abos.dbms.Instrument;
import org.imos.abos.dbms.InstrumentCalibrationValue;
import org.imos.abos.dbms.Mooring;
import org.imos.abos.dbms.ParameterCodes;
import org.imos.abos.netcdf.NetCDFfile;
import org.wiley.core.Common;
import org.wiley.core.forms.MemoryWindow;
import org.wiley.util.SQLWrapper;
import org.wiley.util.StringUtilities;
import ucar.ma2.ArrayByte;
import ucar.ma2.ArrayDouble;
import ucar.ma2.ArrayFloat;
import ucar.ma2.ArrayInt;
import ucar.ma2.DataType;
import ucar.ma2.InvalidRangeException;
import ucar.nc2.Attribute;
import ucar.nc2.Dimension;
import ucar.nc2.NetcdfFileWriter;
import ucar.nc2.Variable;

/**
 *
 * @author peter
 */
public class RasNetCDFcreateForm extends MemoryWindow
{
    private static Logger logger = Logger.getLogger(RasNetCDFcreateForm.class.getName());
    protected static SQLWrapper query = new SQLWrapper();
    
    private Mooring selectedMooring = null;
    
    private String authority = "OS";
    private String facility = "ABOS-SOTS";
    
    protected TimeZone tz = TimeZone.getTimeZone("UTC");
    
    /** Creates new form SBE16CalculationForm */
    public RasNetCDFcreateForm()
    {
        TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
    }
    
    @Override
    public void initialise()
    {
        initComponents();
        
        this.setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        jPanel1 = new javax.swing.JPanel();
        mooringCombo1 = new org.imos.abos.dbms.fields.MooringCombo();
        mooringDescriptionField = new org.wiley.util.basicField();
        authorityCombo = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        runButton = new javax.swing.JButton();
        quitButton = new javax.swing.JButton();

        setTitle("Create NetCDF Form");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent evt)
            {
                formWindowClosing(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        mooringCombo1.setDescriptionField(mooringDescriptionField);
        mooringCombo1.setOrientation(0);
        mooringCombo1.addPropertyChangeListener(new java.beans.PropertyChangeListener()
        {
            public void propertyChange(java.beans.PropertyChangeEvent evt)
            {
                mooringCombo1PropertyChange(evt);
            }
        });

        mooringDescriptionField.setEnabled(false);

        authorityCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "OS", "IMOS" }));

        jLabel1.setText("Authority");

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(jLabel1)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(authorityCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 169, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(18, 18, 18)
                        .add(mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 343, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(38, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(mooringDescriptionField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(authorityCombo, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(jLabel1))
                        .add(46, 46, 46)
                        .add(mooringCombo1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 21, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .add(306, 306, 306))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        runButton.setText("Run");
        runButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                runButtonActionPerformed(evt);
            }
        });
        jPanel2.add(runButton);

        quitButton.setText("Quit");
        quitButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                quitButtonActionPerformed(evt);
            }
        });
        jPanel2.add(quitButton);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 300, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 21, Short.MAX_VALUE)
                .add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );

        getAccessibleContext().setAccessibleName("SBE16 Extraction Processing Form");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void quitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitButtonActionPerformed
        cleanup();
    }//GEN-LAST:event_quitButtonActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        cleanup();
    }//GEN-LAST:event_formWindowClosing

    private void runButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runButtonActionPerformed

        selectedMooring = mooringCombo1.getSelectedMooring();

        if(selectedMooring == null)
        {
            Common.showMessage(this,"No Mooring Selected","You must select a mooring before running any calculations");
            return;
        }
        
        authority = (String)authorityCombo.getSelectedItem();
        
        final Color bg = runButton.getBackground();
        runButton.setText("Running...");
        runButton.setBackground(Color.RED);
        runButton.setForeground(Color.WHITE);

        Thread worker = new Thread()
        {
            @Override
            public void run()
            {
                SwingUtilities.invokeLater(new Runnable()
                {
                @Override
                    public void run()
                    {
                        runButton.setBackground(bg);
                        runButton.setForeground(Color.BLACK);
                        runButton.setText("Run");
                        repaint();
                        createTimeArray(selectedMooring.getMooringID());
                        createDepthArray(selectedMooring.getMooringID());
                        createCDFFile();                        
                    }
                });
            }
        };

        worker.start();      
        
    }//GEN-LAST:event_runButtonActionPerformed

    private void mooringCombo1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_mooringCombo1PropertyChange
        String propertyName = evt.getPropertyName();
        //logger.debug(evt.getPropertyName());
        if(propertyName.equalsIgnoreCase("MOORING_SELECTED")) 
        {
            Mooring selectedItem = (Mooring) evt.getNewValue();
        }
    }//GEN-LAST:event_mooringCombo1PropertyChange

    protected Timestamp endTime = null;
    protected Timestamp startTime = null;
    protected ArrayList<Timestamp> timeArray;
    
    protected String getFileName()
    {
        SimpleDateFormat nameFormatter = new SimpleDateFormat("yyyyMMdd'T'HHmmss'Z'");
        nameFormatter.setTimeZone(tz);

        String filename = "ABOS_NetCDF.nc";
        String deployment = selectedMooring.getMooringID();
        String mooring = deployment.substring(0, deployment.indexOf("-"));
        
        if (authority.equals("IMOS"))
        {
            // IMOS_ABOS-SOTS_20110803T115900Z_PULSE_FV01_PULSE-8-2011_END-20120719T214600Z_C-20130724T051434Z.nc
            filename = //System.getProperty("user.home")
                            //+ "/"
                                                        authority 
                            + "_ABOS-" + facility + "_"
                            + nameFormatter.format(startTime)
                            + "_" + mooring.toUpperCase() + "_FV01"
                            + "_" + deployment.toUpperCase() + "-RAS-NUTRIENTS"
                            + "_END-"
                            + nameFormatter.format(endTime)
                            + "_C-"               
                            + nameFormatter.format(System.currentTimeMillis())
                            + ".nc"
                            ;
        }
        else if (authority.equals("OS"))
        {
            filename = "OS"
                        + "_" + facility
                        + "_" + deployment.toUpperCase()
                        + "_D"
                        + ".nc"
                        ;
        }

        return filename;
    }    
    
    private class InstanceCoord
    {
        String[] params;
        Double[] depths;
        Integer[] instruments;
        Dimension dim;
        private ArrayFloat.D1 variable;
        private ArrayList<Dimension> timeAndDim;
        String[] varName;
        String[] varNameQC;
        ArrayFloat.D2[] dataVar;
        ArrayByte.D2[] dataVarQC;
        ArrayList<Dimension> dimList;        
        private Variable dimVar;
        private Variable[] var;
        private Variable[] varQC;

        private void createParams(String[] string)
        {
            params = string;
            
            int l = params.length;
            dataVar = new ArrayFloat.D2[l];
            dataVarQC = new ArrayByte.D2[l];
            varName = new String[l];
            varNameQC = new String[l];
        }

        private String getDimensionName()
        {
            String dimensionName;

            dimensionName = "DEPTH_";
            for (int p = 0; p < params.length; p++)
            {
                dimensionName += params[p].substring(0, 2);
                if (p < params.length - 1)
                {
                    dimensionName += "_";
                }
            }

            return dimensionName;
        }

        private String getDepthsString()
        {
            String ds = "";
            for (int d = 0; d < depths.length; d++)
            {
                ds += depths[d].doubleValue();
                if (d < depths.length - 1)
                {
                    ds += "; ";
                }
            }

            return ds;
        }

        private void createDepths(BigDecimal[] bigDecimal)
        {
            int l = bigDecimal.length;
            Double[] dDepths = new Double[l];
            int j = 0;
            for (int d = 0; d < l; d++)
            {
                BigDecimal s = bigDecimal[d];
                dDepths[j++] = s.doubleValue();
            }
            depths = dDepths;
        }

        private void createVariables()
        {
            var = new Variable[params.length];
            varQC = new Variable[params.length];
        }

        private String createParams(int p, int RECORD_COUNT)
        {
            String pt = params[p].trim();
            ArrayFloat.D2 dataTemp = new ArrayFloat.D2(RECORD_COUNT, depths.length);
            ArrayByte.D2 dataTempQC = new ArrayByte.D2(RECORD_COUNT, depths.length);
            byte b = -128;
            for (int i = 0; i < RECORD_COUNT; i++)
            {
                for (int j = 0; j < depths.length; j++)
                {
                    dataTemp.set(i, j, Float.NaN);
                    dataTempQC.set(i, j, b);
                }
            }
            varName[p] = pt;
            dataVar[p] = dataTemp;
            dataVarQC[p] = dataTempQC;
            var[p] = f.dataFile.addVariable(null, pt, DataType.FLOAT, timeAndDim);
            var[p].addAttribute(new Attribute("sensor_depth", getDepthsString()));
            addVariableAttributes(this, p);

            String qc = pt + "_QC";
            var[p].addAttribute(new Attribute("ancillary_variables", qc));
            var[p].addAttribute(new Attribute("coordinates", "TIME " + getDimensionName() + " LATITUDE LONGITUDE"));

            varNameQC[p] = qc;
            varQC[p] = f.dataFile.addVariable(null, qc, DataType.BYTE, timeAndDim);
            varQC[p].addAttribute(new Attribute("long_name", "quality flag"));
            varQC[p].addAttribute(new Attribute("conventions", "OceanSITES reference table 2"));
            b = -128;
            varQC[p].addAttribute(new Attribute("_FillValue", b));
            b = 0;
            varQC[p].addAttribute(new Attribute("valid_min", b));
            b = 9;
            varQC[p].addAttribute(new Attribute("valid_max", b));
            
            ArrayByte.D1 qcValues = new ArrayByte.D1(8);
            b = 0; qcValues.set(0, b);
            b = 1; qcValues.set(1, b);
            b = 2; qcValues.set(2, b);
            b = 3; qcValues.set(3, b);
            b = 4; qcValues.set(4, b);
            b = 7; qcValues.set(5, b);
            b = 8; qcValues.set(6, b);
            b = 9; qcValues.set(7, b);
            varQC[p].addAttribute(new Attribute("flag_values", qcValues));
            varQC[p].addAttribute(new Attribute("flag_meanings", "unknown good_data probably_good_data potentially_correctable bad_data bad_data nominal_value interpolated_value missing_value"));
            
            return pt;
        }

        private void createDimension()
        {
                dim = f.dataFile.addDimension(null, getDimensionName(), depths.length);
                dimList = new ArrayList<Dimension>();
                dimList.add(dim);
                
                dimVar = f.dataFile.addVariable(null, getDimensionVariableName(), DataType.FLOAT, dimList);
                variable = new ArrayFloat.D1(dim.getLength());
                for (int j = 0; j < dim.getLength(); j++)
                {
                    Double currentDepth = depths[j];
                    variable.set(j, currentDepth.floatValue());
                }

                System.out.println("Create Dimension " + getDimensionName() + " " + f.timeDim.getLength() + " x " + dim.getLength());
                ArrayList dims = new ArrayList();
                dims.add(f.timeDim);
                dims.add(dim);
                timeAndDim = dims;
        }

        private String getDimensionVariableName()
        {
             String dimensionName;

            dimensionName = "DEPTH_";
            for (int p = 0; p < params.length; p++)
            {
                dimensionName += params[p].substring(0, 2);
                if (p < params.length - 1)
                {
                    dimensionName += "_";
                }
            }

            return dimensionName;
       }
    }
    ArrayList<InstanceCoord> instanceCoords;

    protected void createDepthArray(String mooringID)
    {
        String SQL =  "SELECT array_agg(parameter_code) AS parameters, instruments, depths AS depths FROM "
                    + " (SELECT parameter_code, array_agg(instrument_id) AS instruments, array_agg(depth) AS depths FROM "
                    + "    (SELECT parameter_code, c.instrument_id, depth FROM "
                    + "      (SELECT parameter_code, mooring_id, instrument_id FROM raw_instrument_data "
                    +         " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID()) 
                    +         " AND instrument_id = 1632 "
                    + "          GROUP BY parameter_code, mooring_id, instrument_id ORDER BY 1, 2, 3"
                    + "      ) AS c"
                    + "      JOIN mooring_attached_instruments AS m ON (c.mooring_id = m.mooring_id AND c.instrument_id = m.instrument_id) "
                    + "          ORDER BY parameter_code, depth"
                    + "    ) AS a"
                    + "    GROUP BY parameter_code"
                    + " ) AS b"
                    + " GROUP BY depths, instruments";
        
        instanceCoords = new ArrayList<InstanceCoord>();
        logger.debug(SQL);
        query.setConnection(Common.getConnection());
        query.executeQuery(SQL);
        Vector depthSet = RasNetCDFcreateForm.query.getData();
        
        if (depthSet != null && depthSet.size() > 0)
        {
            for (int i = 0; i < depthSet.size(); i++)
            {
                Vector row = (Vector) depthSet.get(i);
                Array params = (Array)row.get(0);
                
                InstanceCoord dc = new InstanceCoord();
                try
                {
                    dc.createParams((String[])params.getArray());                                       
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(RasNetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                Array instruments = (Array)row.get(1);
                System.out.println("instruments " + instruments);
                try
                {
                    dc.instruments = (Integer[])instruments.getArray();
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(RasNetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                
                Array depths = (Array)row.get(2);
                System.out.println("depths " + depths);
                try
                {
                    dc.createDepths((BigDecimal[])depths.getArray());
                    
                }
                catch (SQLException ex)
                {
                    java.util.logging.Logger.getLogger(RasNetCDFcreateForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                instanceCoords.add(dc);
            }
        }
        logger.debug("Finished generating depth array, number of depths is " + instanceCoords.size());
    }

    protected void createTimeArray(String mooringID)
    {
        timeArray = new ArrayList();
                
        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));
        selectedMooring = Mooring.selectByMooringID(mooringID);
        startTime = selectedMooring.getTimestampIn();
        endTime = selectedMooring.getTimestampOut();
        
        String SQL = "SELECT DISTINCT(data_timestamp) " 
                + " FROM raw_instrument_data"
                + " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID())
                + " AND instrument_id = 1632 "
                + " AND data_timestamp between "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(startTime))
                + " AND "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(endTime))
                + " ORDER BY 1"
                ;
        
        // logger.debug(SQL);
        RasNetCDFcreateForm.query.setConnection(Common.getConnection());
        RasNetCDFcreateForm.query.executeQuery(SQL);
        Vector dataSet = RasNetCDFcreateForm.query.getData();
        if (dataSet != null && dataSet.size() > 0)
        {
            for (int i = 0; i < dataSet.size(); i++)
            {
                Vector row = (Vector) dataSet.get(i);
                Timestamp t = (Timestamp) row.get(0);
                System.out.println("Data timestamp " + t);
                timeArray.add(t);
            }
            logger.debug("Found " + dataSet.size() + " records for timestamp ");
        }
                        
        logger.debug("Finished generating time array Total Elements: " + timeArray.size());
    }

    protected ArrayList<RasNetCDFcreateForm.ParamDatum> getDataForParameter(String param, Integer instrumentID)
    {
        ArrayList<RasNetCDFcreateForm.ParamDatum> set = new ArrayList();
        logger.debug("Searching for data for param " + param + " instrument " + instrumentID);
        String SQL = "SELECT data_timestamp," 
                + " instrument_id,"
                + " depth,"
                + " parameter_code,"
                + " parameter_value,"
                + " quality_code"
                + " FROM raw_instrument_data"
                + " WHERE mooring_id = " + StringUtilities.quoteString(selectedMooring.getMooringID())
                + " AND parameter_code = " + StringUtilities.quoteString(param)
                + " AND instrument_id = " + instrumentID
                + " AND data_timestamp between "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(startTime))
                + " AND "
                + StringUtilities.quoteString(Common.getRawSQLTimestamp(endTime))
                + " ORDER BY data_timestamp"
                ;
        
        // logger.debug(SQL);
        RasNetCDFcreateForm.query.setConnection(Common.getConnection());
        RasNetCDFcreateForm.query.executeQuery(SQL);
        Vector dataSet = RasNetCDFcreateForm.query.getData();
        if (dataSet != null && dataSet.size() > 0)
        {
            for (int i = 0; i < dataSet.size(); i++)
            {
                Vector row = (Vector) dataSet.get(i);
                Timestamp t = (Timestamp) row.get(0);
                Integer ix = ((Number) row.get(1)).intValue();
                Double d = ((Number) row.get(2)).doubleValue();
                String p = (String) row.get(3);
                Double v = ((Number) row.get(4)).doubleValue();
                String q = (String) row.get(5);
                RasNetCDFcreateForm.ParamDatum dd = new RasNetCDFcreateForm.ParamDatum(t, ix, p, d, v, q);
                set.add(dd);
            }
            logger.debug("Found " + dataSet.size() + " records for instrument " + instrumentID);
            
            return set;
        }
        
        logger.debug("Found 0 records for pressure data for depth " + instrumentID);
        return null;
    }

    protected void writeInstanceCoordinateVariableAttributes()
    {
        for(InstanceCoord ic : instanceCoords)
        {
            ic.dimVar.addAttribute(new Attribute("name", "nominal_depth"));
            ic.dimVar.addAttribute(new Attribute("long_name", "nominal depth of each sensor"));
            ic.dimVar.addAttribute(new Attribute("units", "meters"));
            ic.dimVar.addAttribute(new Attribute("positive", "down"));
            ic.dimVar.addAttribute(new Attribute("axis", "Z"));
            ic.dimVar.addAttribute(new Attribute("comment", "These are nominal values. Use PRES to derive time-varying depths of instruments, as the mooring may tilt in ambient currents."));
            ic.dimVar.addAttribute(new Attribute("reference", "sea_level"));
            ic.dimVar.addAttribute(new Attribute("valid_min", 0.0f));
            ic.dimVar.addAttribute(new Attribute("valid_max", 1200.0f));
            String comment = "depths for parameters ";
            for (int p = 0; p < ic.params.length; p++)
            {
                comment += ic.params[p].trim();
                if (p < ic.params.length - 1)
                {
                    comment += "; ";
                }
            }
            ic.dimVar.addAttribute(new Attribute("params", comment));
        }
    }

    protected void addVariableAttributes(InstanceCoord dc, int p)
    {
        ParameterCodes param = ParameterCodes.selectByID(dc.params[p]);
        Variable variable = dc.var[p];

        String sensor = "";
        String serialNo = "";
        
        for(int i=0;i<dc.instruments.length;i++)
        {
            Instrument ins = Instrument.selectByInstrumentID(dc.instruments[i]);
            if (ins != null)
            {
                sensor += ins.getMake() + "-" + ins.getModel();
                if (i < dc.instruments.length-1)
                    sensor += "; ";
                serialNo += ins.getSerialNumber();
                if (i < dc.instruments.length-1)
                    serialNo += "; ";
                
                ArrayList<InstrumentCalibrationValue> values = InstrumentCalibrationValue.selectByInstrumentAndMooring(ins.getInstrumentID(), selectedMooring.getMooringID());            

                for(InstrumentCalibrationValue v : values)
                {
                    // System.out.println("Calibration Value " + v.getParameterCode() + " " + v.getParameterValue());
                    if (v.getDataType().contains("NUMBER"))
                    {
                        variable.addAttribute(new Attribute("calibration_" + ins.getSerialNumber() + "_" + v.getParameterCode(), Double.parseDouble(v.getParameterValue())));
                    }
                    else
                    {
                        variable.addAttribute(new Attribute("calibration_" + ins.getSerialNumber() + "_" + v.getParameterCode(), v.getParameterValue()));
                    }
                }
            }
        }
        variable.addAttribute(new Attribute("sensor_name", sensor));
        variable.addAttribute(new Attribute("sensor_serial_number", serialNo));
            
        
        if(param != null)
        {
            variable.addAttribute(new Attribute("name", param.getDescription()));
            if (param.getUnits() != null)
            {
                variable.addAttribute(new Attribute("units", param.getUnits()));
            }
            
            if(param.getNetCDFStandardName() != null && !(param.getNetCDFStandardName().trim().isEmpty()))
                variable.addAttribute(new Attribute("standard_name", param.getNetCDFStandardName()));
            else if (param.getNetCDFStandardName() != null)
                variable.addAttribute(new Attribute("long_name", param.getNetCDFLongName()));
            
            if(param.getMinimumValidValue() != null)
                variable.addAttribute(new Attribute("valid_min", param.getMinimumValidValue()));
            
            if(param.getMaximumValidValue() != null)
                variable.addAttribute(new Attribute("valid_max", param.getMaximumValidValue()));
            
            variable.addAttribute(new Attribute("_FillValue", Float.NaN));
            variable.addAttribute(new Attribute("quality_control_set", 1.0f));
            //f.dataFile.addVariableAttribute(variable, "csiro_instrument_id", instrumentID);
        }
        
        // TODO: Should include instrument_id select also
        String SQL = "SELECT attribute_name, attribute_type, attribute_value FROM netcdf_attributes "
                        + " WHERE (deployment = " + StringUtilities.quoteString(f.getDeployment()) + " OR deployment = '*')"
                        + " AND parameter = " + StringUtilities.quoteString(dc.varName[p].trim()) + " ORDER BY attribute_name";
        
        query.setConnection(Common.getConnection());
        query.executeQuery(SQL);
        Vector attributeSet = query.getData();
        if (attributeSet != null && attributeSet.size() > 0)
        {
            for (int i = 0; i < attributeSet.size(); i++)
            {
                Vector row = (Vector) attributeSet.get(i);
                String name = (String)(row.get(0));
                String type = (String)(row.get(1));
                String value = (String)(row.get(2));

                logger.debug("PARAMETER: " + name + " " + value);
                
                if (type.startsWith("NUMBER"))
                {
                    variable.addAttribute(new Attribute(name.trim(), new Double(value.trim())));                    
                }
                else
                {
                    variable.addAttribute(new Attribute(name.trim(), value.trim()));
                }
                
            }
        }
        
    }

    NetCDFfile f = null;

    protected void createCDFFile()
    {
        String filename = getFileName();
        int RECORD_COUNT = timeArray.size();
        f = new NetCDFfile();
        try
        {
            // Create new netcdf-3 file with the given filename
            f.createFile(filename);
            f.setMooring(selectedMooring);
            f.setAuthority(authority);
            f.setFacility(facility);
            f.writeGlobalAttributes();

            // Define the coordinate variables.
            // Add TIME coordinate
            f.createCoordinateVariables(timeArray.size());
            f.writeCoordinateVariables(timeArray);
            
            // Add Depth coords
            for(InstanceCoord dc : instanceCoords)
            {
                dc.createDimension();
            }

            //
            // got to add the variables before you can write their attributes
            //
            f.writeCoordinateVariableAttributes();
            writeInstanceCoordinateVariableAttributes();
            
            for (InstanceCoord ic : instanceCoords)
            {                
                ic.createVariables();
                
                for (int p=0;p<ic.params.length;p++)
                {
                    String pt = ic.createParams(p, RECORD_COUNT);
                    for (int d=0;d<ic.instruments.length;d++)
                    {
                        ArrayList<ParamDatum> masterSet = getDataForParameter(pt, ic.instruments[d]);
                        if (masterSet != null && masterSet.size() > 0)
                        {
                            logger.debug("Processing instrument/parameter " + pt + " at depth " + masterSet.get(0).depth + " size " + masterSet.size());

                            int record = 0;
                            int matchedElements = 0;
                            Double value;
                            for (int setSize = 0; setSize < masterSet.size(); setSize++)
                            {
                                Timestamp currentTime = timeArray.get(record);
                                ParamDatum currentValue = masterSet.get(setSize);
                                while (currentTime.before(currentValue.ts))
                                {
                                    currentTime = timeArray.get(++record);
                                }
                                if (currentValue.ts.equals(currentTime))
                                {
                                    matchedElements++;
                                    value = currentValue.val;
                                    ic.dataVar[p].set(record, d, value.floatValue());
                                    byte b = 0;
                                    if (currentValue.quality.trim().equals("BAD"))
                                    {
                                        b = 4;
                                    }
                                    ic.dataVarQC[p].set(record, d, b);
                                }
                                record++;                                                
                            }
                           logger.debug("Matched " + matchedElements + " records for " + pt);
                        }
                    }                    
                }
            }
            //Create the file. At this point the (empty) file will be written to disk
            f.dataFile.create();
            for(InstanceCoord dc : instanceCoords)
            {
                f.dataFile.write(dc.dimVar, dc.variable);
            }
            f.dataFile.write(f.vTime, f.times);

            f.writePosition(selectedMooring.getLatitudeIn(), selectedMooring.getLongitudeIn());
            
            for(InstanceCoord dc : instanceCoords)
            {
                for(int p=0;p<dc.dataVar.length;p++)
                {
                    f.dataFile.write(dc.var[p], dc.dataVar[p]);
                    f.dataFile.write(dc.varQC[p], dc.dataVarQC[p]);
                }
            }
        }
        catch (IOException e)
        {
            e.printStackTrace(System.err);
        }
        catch (InvalidRangeException e)
        {
            e.printStackTrace(System.err);
        }
        finally
        {
            if (f.dataFile != null)
            {
                try
                {
                    f.dataFile.close();
                }
                catch (IOException ioe)
                {
                    ioe.printStackTrace();
                }
            }
        }
        System.out.println("*** SUCCESS writing file " + filename);
    }

    protected class ParamDatum
    {
        public Timestamp ts;
        public Integer instrumentID;
        public String paramCode;
        public Double depth;
        public Double val;
        public String quality;

        public ParamDatum()
        {
            super();
        }

        public ParamDatum(Timestamp t, Integer i, String p, Double d, Double v, String q)
        {
            super();
            ts = t;
            instrumentID = i;
            paramCode = p.trim();
            depth = d;
            val = v;
            quality = q;
        }
    }
    
    
    /**
    * @param args the command line arguments
    */
    public static void main(String[] args)
    {
        try
        {
	    // Set cross-platform Java L&F (also called "Metal")
            UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
        }
        catch (UnsupportedLookAndFeelException e)
        {
           // handle exception
        }
        catch (ClassNotFoundException e)
        {
           // handle exception
        }
        catch (InstantiationException e)
        {
           // handle exception
        }
        catch (IllegalAccessException e)
        {
           // handle exception
        }

        String $HOME = System.getProperty("user.home");
        PropertyConfigurator.configure("log4j.properties");
        Common.build($HOME + "/ABOS/ABOS.properties");
        
        RasNetCDFcreateForm form = new RasNetCDFcreateForm();
        form.setLocationRelativeTo(null);
        form.initialise();
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox authorityCombo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private org.imos.abos.dbms.fields.MooringCombo mooringCombo1;
    private org.wiley.util.basicField mooringDescriptionField;
    private javax.swing.JButton quitButton;
    private javax.swing.JButton runButton;
    // End of variables declaration//GEN-END:variables

}
